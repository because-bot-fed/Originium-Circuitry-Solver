<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Originium Circuitry Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
            background: #0a0a0f;
            min-height: 100vh;
            color: #c8c8c8;
            padding: 25px 20px;
            user-select: none;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 15px;
            font-weight: 500;
            font-size: 1.3rem;
            color: #ffffff;
            letter-spacing: 0.5px;
        }

        /* Mode Toggle */
        .mode-toggle-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-toggle {
            display: inline-flex;
            background: #0a0a0a;
            border-radius: 4px;
            padding: 4px;
            border: 1px solid #222;
        }

        .mode-toggle-btn {
            padding: 10px 32px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: transparent;
            border: none;
            color: #444;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .mode-toggle-btn:hover {
            color: #666;
        }

        .mode-toggle-btn.active {
            background: linear-gradient(135deg, #1a3a1a, #2d5a2d);
            color: #39ff14;
            box-shadow: 0 2px 8px rgba(57, 255, 20, 0.2);
        }

        h2 {
            font-size: 0.85rem;
            font-weight: 500;
            color: #888;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Configuration Panel */
        .config-panel {
            display: flex;
            justify-content: center;
            gap: 25px;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .config-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .config-group label {
            font-size: 0.85rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .config-group input[type="number"] {
            width: 60px;
            padding: 10px 12px;
            border: 1px solid #222;
            border-radius: 2px;
            background: #111;
            color: #fff;
            font-size: 1rem;
            text-align: center;
            transition: border-color 0.2s;
        }

        .config-group input[type="number"]:focus {
            outline: none;
            border-color: #444;
        }

        .btn {
            padding: 10px 24px;
            border: none;
            border-radius: 2px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #333;
        }

        .btn-primary:hover {
            background: #252525;
            border-color: #444;
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px 20px;
            color: #fff;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            animation: toastIn 0.3s ease;
            max-width: 350px;
        }

        .toast.success {
            border-color: #39ff14;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a2a0a 100%);
        }

        .toast.error {
            border-color: #ff3939;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a0a0a 100%);
        }

        .toast.info {
            border-color: #00bfff;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a1a2a 100%);
        }

        .toast.fade-out {
            animation: toastOut 0.3s ease forwards;
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateX(50px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(50px); }
        }

        .btn-solve {
            background: #1a3a1a;
            color: #39ff14;
            border: 1px solid #2d5a2d;
        }

        .btn-solve:hover {
            background: #224422;
            border-color: #3d7a3d;
        }

        .btn-clear {
            background: #111;
            color: #888;
            border: 1px solid #222;
        }

        .btn-clear:hover {
            background: #1a1a1a;
            color: #aaa;
        }

        /* Puzzle Area */
        .puzzle-area {
            display: flex;
            justify-content: center;
            overflow-x: auto;
            padding: 10px 0;
            gap: 20px;
        }

        .puzzle-wrapper {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
        }

        /* Shape Selector Panel */
        .shape-selector {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 10px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #1a1a1a;
            align-self: flex-start;
        }

        .shape-selector-title {
            font-size: 0.65rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
            text-align: center;
            grid-column: span 2;
        }

        .shape-selector-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .shape-selector-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: #111;
            border-radius: 2px;
            border: 2px solid #222;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.4;
        }

        .shape-selector-item:hover {
            background: #161616;
            border-color: #333;
        }

        .shape-selector-item.active {
            opacity: 1;
            border-color: #39ff14;
            background: #0a1a0a;
        }

        .shape-selector-item .shape-mini-grid {
            display: grid;
            gap: 1px;
        }

        .shape-selector-item .shape-mini-cell {
            width: 10px;
            height: 10px;
            background: #222;
            border-radius: 0;
        }

        .shape-selector-item .shape-mini-cell.filled {
            background: #39ff14;
        }

        .shape-selector-item.active .shape-mini-cell.filled {
            background: linear-gradient(145deg, #39ff14, #32cd32);
        }

        /* Puzzle Mode Styles */
        .puzzle-config-panel {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #1a1a1a;
        }

        .puzzle-config-panel h2 {
            text-align: center;
            font-size: 1rem;
            color: #888;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .puzzle-config-panel h3 {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .puzzle-difficulty-selector {
            margin-bottom: 25px;
        }

        .difficulty-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 10px 20px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            color: #666;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficulty-btn:hover {
            background: #1a1a1a;
            color: #888;
        }

        .difficulty-btn.active {
            background: #1a3a1a;
            color: #39ff14;
            border-color: #2d5a2d;
        }

        .puzzle-custom-config {
            margin-bottom: 25px;
        }

        .puzzle-custom-config.hidden {
            display: none;
        }

        .custom-mode-toggle {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .custom-mode-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            color: #888;
            font-size: 0.85rem;
        }

        .custom-mode-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .custom-mode-toggle label:hover {
            color: #aaa;
        }

        .difficulty-help {
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .help-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background: #333;
            border: 1px solid #444;
            border-radius: 50%;
            color: #888;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .help-btn:hover {
            background: #444;
            color: #aaa;
            border-color: #555;
        }

        .help-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 10px;
            padding: 12px 15px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 0.8rem;
            line-height: 1.6;
            color: #aaa;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .help-tooltip.visible {
            display: block;
        }

        .help-tooltip .help-q {
            color: #39ff14;
            font-weight: bold;
        }

        .puzzle-difficulty-selector {
            position: relative;
        }

        .custom-config-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-item label {
            font-size: 0.75rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .size-inputs input {
            width: 60px;
            padding: 8px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            color: #fff;
            text-align: center;
        }

        .size-inputs span {
            color: #444;
        }

        .color-toggles {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .color-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            font-size: 0.75rem;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-toggle input {
            display: none;
        }

        .color-toggle.green.active { background: #1a3a1a; color: #39ff14; border-color: #2d5a2d; }
        .color-toggle.blue.active { background: #1a2a4a; color: #00bfff; border-color: #2d4a7a; }
        .color-toggle.red.active { background: #3a1a1a; color: #ff3939; border-color: #5a2d2d; }
        .color-toggle.purple.active { background: #2a1a3a; color: #bf39ff; border-color: #4a2d5a; }

        .feature-toggles {
            display: flex;
            gap: 15px;
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #888;
            cursor: pointer;
        }

        .feature-toggle input {
            accent-color: #39ff14;
        }

        .btn-generate-puzzle {
            width: 100%;
            padding: 14px;
            background: #1a3a1a;
            color: #39ff14;
            border: 1px solid #2d5a2d;
            border-radius: 2px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-generate-puzzle:hover {
            background: #224422;
            border-color: #3d7a3d;
        }

        .puzzle-play-area {
            margin-top: 20px;
        }

        .puzzle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .puzzle-main {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .puzzle-grid-area {
            display: flex;
            flex-direction: column;
        }

        .puzzle-grid-row {
            display: flex;
        }

        .puzzle-grid {
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            border-radius: 2px;
        }

        .puzzle-col-req {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 4px;
        }

        .puzzle-row-req {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            padding-right: 4px;
        }

        .prescriptive-bar {
            --green-accent: #39ff14;
            --blue-accent: #00bfff;
            --red-accent: #ff3939;
            --purple-accent: #bf39ff;
        }

        .prescriptive-segment {
            background: transparent;
            transition: background 0.2s;
        }

        .prescriptive-segment.filled {
            background: currentColor;
        }

        .prescriptive-bar.green .prescriptive-segment { border-color: #39ff14; }
        .prescriptive-bar.green .prescriptive-segment.filled { background: #39ff14; }
        .prescriptive-bar.blue .prescriptive-segment { border-color: #00bfff; }
        .prescriptive-bar.blue .prescriptive-segment.filled { background: #00bfff; }
        .prescriptive-bar.red .prescriptive-segment { border-color: #ff3939; }
        .prescriptive-bar.red .prescriptive-segment.filled { background: #ff3939; }
        .prescriptive-bar.purple .prescriptive-segment { border-color: #bf39ff; }
        .prescriptive-bar.purple .prescriptive-segment.filled { background: #bf39ff; }

        .prescriptive-bar.error {
            background: linear-gradient(to top, rgba(255, 0, 0, 0.3), transparent);
            animation: error-pulse 1s ease-in-out infinite;
        }

        /* Drag placement highlighting */
        .cell.placement-valid {
            background: rgba(57, 255, 20, 0.3) !important;
            box-shadow: inset 0 0 10px rgba(57, 255, 20, 0.5);
        }

        .cell.placement-invalid {
            background: rgba(255, 57, 57, 0.3) !important;
            box-shadow: inset 0 0 10px rgba(255, 57, 57, 0.5);
        }

        .cell.placed {
            cursor: pointer;
        }

        /* Legacy border logic removed - see .cell definition */

        #drag-ghost .cell {
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .puzzle-shape-palette {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 2px;
            padding: 15px;
            min-width: 120px;
        }

        .puzzle-shape-palette h3 {
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            text-align: center;
        }

        .palette-shapes {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .palette-shape {
            padding: 8px;
            background: #111;
            border: 2px solid #222;
            border-radius: 2px;
            cursor: grab;
            transition: all 0.2s;
        }

        .palette-shape:hover {
            background: #1a1a1a;
            border-color: #333;
        }

        .palette-shape.green { border-color: #1a3a1a; }
        .palette-shape.green:hover { border-color: #39ff14; }
        .palette-shape.blue { border-color: #1a2a4a; }
        .palette-shape.blue:hover { border-color: #00bfff; }
        .palette-shape.red { border-color: #3a1a1a; }
        .palette-shape.red:hover { border-color: #ff3939; }
        .palette-shape.purple { border-color: #2a1a3a; }
        .palette-shape.purple:hover { border-color: #bf39ff; }

        .palette-shape.placed {
            opacity: 0.3;
            pointer-events: none;
        }

        .shape-preview-cell {
            background: #333;
            border: 1px solid #444;
        }
        .shape-preview-cell.green { background: #1a5c1a; border-color: #39ff14; }
        .shape-preview-cell.blue { background: #0066a0; border-color: #00bfff; }
        .shape-preview-cell.red { background: #8b1a1a; border-color: #ff3939; }
        .shape-preview-cell.purple { background: #5c1a8b; border-color: #bf39ff; }

        .puzzle-actions {
            display: flex;
            gap: 12px;
        }

        /* Hide Blue toggle button */
        .hide-blue-btn {
            margin-top: 8px;
            padding: 6px 10px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            color: #666;
            cursor: pointer;
            transition: all 0.15s;
            width: 100%;
        }

        .hide-blue-btn:hover {
            background: #1a1a1a;
            color: #888;
        }

        .hide-blue-btn.active {
            background: #1a2a4a;
            color: #00bfff;
            border-color: #00bfff;
        }

        /* Shape count badge */
        .shape-selector-item {
            position: relative;
        }

        .shape-count-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #39ff14, #32cd32);
            color: #000;
            font-size: 0.7rem;
            font-weight: 700;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s ease;
        }

        .shape-selector-item.active .shape-count-badge {
            opacity: 1;
            transform: scale(1);
        }

        /* Sliding word toggle */
        .input-mode-slider {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .slider-toggle {
            display: inline-flex;
            align-items: center;
            background: #0a0a0a;
            border-radius: 4px;
            padding: 5px;
            border: 1px solid #222;
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .slider-option {
            padding: 10px 28px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #444;
            border-radius: 2px;
            transition: color 0.25s ease;
            z-index: 1;
            position: relative;
        }

        .slider-option.active {
            color: #fff;
        }

        .slider-bg {
            position: absolute;
            top: 5px;
            height: calc(100% - 10px);
            background: linear-gradient(135deg, #1a3a1a, #2d5a2d);
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
            box-shadow: 0 2px 8px rgba(57, 255, 20, 0.2);
        }

        .bar-input {
            display: flex;
            flex-direction: column-reverse;
            gap: 1px;
            justify-content: flex-end;
            background: transparent;
            padding: 0;
        }

        .bar-segment {
            border-radius: 1px;
            cursor: pointer;
            transition: all 0.1s;
            background: transparent;
        }

        .bar-input.green .bar-segment {
            border: 2px solid #39ff14;
        }

        .bar-input.green .bar-segment:hover {
            background: rgba(57, 255, 20, 0.2);
        }

        .bar-input.green .bar-segment.filled {
            background: #39ff14;
        }

        .bar-input.blue .bar-segment {
            border: 2px solid #00bfff;
        }

        .bar-input.blue .bar-segment:hover {
            background: rgba(0, 191, 255, 0.2);
        }

        .bar-input.blue .bar-segment.filled {
            background: #00bfff;
        }

        .bar-input.red .bar-segment {
            border: 2px solid #ff3939;
        }

        .bar-input.red .bar-segment:hover {
            background: rgba(255, 57, 57, 0.2);
        }

        .bar-input.red .bar-segment.filled {
            background: #ff3939;
        }

        .bar-input.purple .bar-segment {
            border: 2px solid #bf39ff;
        }

        .bar-input.purple .bar-segment:hover {
            background: rgba(191, 57, 255, 0.2);
        }

        .bar-input.purple .bar-segment.filled {
            background: #bf39ff;
        }

        /* Bar error state */
        .bar-input.error {
            background: linear-gradient(to top, rgba(255, 0, 0, 0.3), transparent);
            border-radius: 2px;
            animation: error-pulse 1s ease-in-out infinite;
        }

        @keyframes error-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); }
        }

        /* Column bar inputs - vertical bars side by side */
        .col-req .bar-input {
            width: 33px;
            height: 60px;
        }

        /* Row bar inputs - horizontal bars stacked vertically, fill from right */
        .row-req .bar-input {
            width: 60px;
            height: 33px;
            flex-direction: row-reverse;
        }

        /* Column Requirements - ABOVE the grid */
        .col-requirements {
            display: flex;
            gap: 0;
            margin-bottom: 0;
        }

        .col-req-spacer {
            flex-shrink: 0;
        }

        .col-req {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-end;
            gap: 1px;
            width: 68px;
        }

        /* Custom Stepper Control */
        .stepper {
            display: flex;
            flex-direction: column;
            border-radius: 2px;
            overflow: hidden;
            background: #0a0a0a;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .stepper:hover {
            background: #0f0f0f;
        }

        .stepper.green {
            border-color: #1a3a1a;
        }

        .stepper.green:hover {
            border-color: #2a4a2a;
        }

        .stepper.blue {
            border-color: #1a2a4a;
        }

        .stepper.blue:hover {
            border-color: #2a3a5a;
        }

        .stepper-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
            background: transparent;
        }

        .stepper-btn:hover {
            background: rgba(255,255,255,0.05);
        }

        .stepper-btn:active {
            background: rgba(255,255,255,0.1);
        }

        .stepper-btn svg {
            width: 20px;
            height: 20px;
            opacity: 0.4;
            transition: opacity 0.15s;
        }

        .stepper-btn:hover svg {
            opacity: 0.7;
        }

        .stepper.green .stepper-btn svg {
            fill: #39ff14;
        }

        .stepper.blue .stepper-btn svg {
            fill: #00bfff;
        }

        .stepper-value {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: 600;
            background: transparent;
        }

        .stepper.green .stepper-value {
            color: #39ff14;
        }

        .stepper.blue .stepper-value {
            color: #00bfff;
        }

        .stepper.red .stepper-btn svg {
            fill: #ff3939;
        }

        .stepper.red .stepper-value {
            color: #ff3939;
        }

        .stepper.purple .stepper-btn svg {
            fill: #bf39ff;
        }

        .stepper.purple .stepper-value {
            color: #bf39ff;
        }

        /* Column stepper - vertical orientation */
        .col-req .stepper {
            width: 100%;
            height: 60px;
        }

        .col-req .stepper-btn {
            height: 17px;
        }

        .col-req .stepper-value {
            height: 26px;
            font-size: 1.1rem;
        }

        /* Row stepper - vertical orientation but wider */
        .row-req .stepper {
            width: 51px;
            height: 100%;
        }

        .row-req .stepper-btn {
            height: 19px;
        }

        .row-req .stepper-value {
            flex: 1;
            font-size: 1.1rem;
        }

        /* Grid Container */
        .grid-row {
            display: flex;
            align-items: stretch;
            gap: 0;
        }

        /* Row Requirements - LEFT of the grid */
        .row-requirements {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .row-req {
            display: flex;
            flex-direction: column;
            gap: 1px;
            height: 68px;
            justify-content: center;
            align-items: center;
        }

        /* Grid */
        .grid {
            display: grid;
            gap: 0;
            background: #0f0f0f;
            padding: 0;
            border-radius: 2px;
            border: 1px solid #1a1a1a;
        }

        .cell {
            width: 68px;
            height: 68px;
            /* Variables for theming and borders */
            --bg-color: #111;
            --border-color: #1a1a1a;
            
            /* Border Shadows - Color Layer (3px) */
            --bs-t-c: 0 0 0 0 transparent;
            --bs-r-c: 0 0 0 0 transparent;
            --bs-b-c: 0 0 0 0 transparent;
            --bs-l-c: 0 0 0 0 transparent;
            
            /* Border Shadows - Black Layer (3px + 4px = 7px) */
            --bs-t-b: 0 0 0 0 transparent;
            --bs-r-b: 0 0 0 0 transparent;
            --bs-b-b: 0 0 0 0 transparent;
            --bs-l-b: 0 0 0 0 transparent;

            /* Corner Patching Variables - Default to none */
            --c-tl: none;
            --c-tr: none;
            --c-bl: none;
            --c-br: none;

            /* Default Grid Line */
            --grid-line: inset 0 0 0 1px #1a1a1a;

            background: var(--bg-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.15s ease;
            /* Removed CSS border to prevent miter issues */
            position: relative;
            z-index: 1;
            
            /* Only grid line on the cell itself */
            box-shadow: var(--grid-line); 
        }

        /* Corner Patch Definitions: Mitered joints for Inner Corners 
           (Reduced size to 2.0px/5.0px to prevent visual bulging) */
        .cell.corner-tl { --c-tl: linear-gradient(135deg, var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }
        .cell.corner-tr { --c-tr: linear-gradient(225deg, var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }
        .cell.corner-br { --c-br: linear-gradient(315deg, var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }
        .cell.corner-bl { --c-bl: linear-gradient(45deg,  var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }

        /* Render Borders and Corners on ::before for Colored Cells */
        .cell.green::before, .cell.blue::before, .cell.red::before, .cell.purple::before {
            content: '';
            position: absolute;
            inset: 0;
            background: transparent;
            pointer-events: none;
            z-index: 2; /* Above background */
            display: block !important;
            
            /* Borders */
            box-shadow: 
                var(--bs-t-c), var(--bs-r-c), var(--bs-b-c), var(--bs-l-c),
                var(--bs-t-b), var(--bs-r-b), var(--bs-b-b), var(--bs-l-b);
                
            /* Corners */
            background-image: var(--c-tl), var(--c-tr), var(--c-bl), var(--c-br);
            background-position: top left, top right, bottom left, bottom right;
            background-size: 8px 8px;
            background-repeat: no-repeat;
        }

        /* HIDE the default Center Dot (::after) on colored cells */
        .cell.green::after, .cell.blue::after, .cell.red::after, .cell.purple::after {
            display: none;
        }

        /* SHOW the Lock Icon (::after) on Locked/Blocked cells */
        .cell.locked-green::after,
        .cell.locked-blue::after,
        .cell.locked-red::after,
        .cell.locked-purple::after,
        .cell.blocked::after {
            display: block !important;
            z-index: 10;
        }

        /* Dynamic border application using variables */
        /* Note: We use inset shadows. Color (2px) is drawn ON TOP of Black (5px). 
           So visible black is 3px wide starting at 2px offset. */
        .cell.border-top {
            z-index: 10;
            --bs-t-c: inset 0 2px 0 0 var(--border-color);
            --bs-t-b: inset 0 5px 0 0 #000000;
        }
        .cell.border-right {
            z-index: 10;
            --bs-r-c: inset -2px 0 0 0 var(--border-color);
            --bs-r-b: inset -5px 0 0 0 #000000;
        }
        .cell.border-bottom {
            z-index: 10;
            --bs-b-c: inset 0 -2px 0 0 var(--border-color);
            --bs-b-b: inset 0 -5px 0 0 #000000;
        }
        .cell.border-left {
            z-index: 10;
            --bs-l-c: inset 2px 0 0 0 var(--border-color);
            --bs-l-b: inset 5px 0 0 0 #000000;
        }

        /* X pattern texture */
        .cell::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                linear-gradient(45deg, transparent 42%, #1a1a1a 42%, #1a1a1a 46%, transparent 46%, transparent 54%, #1a1a1a 54%, #1a1a1a 58%, transparent 58%),
                linear-gradient(-45deg, transparent 42%, #1a1a1a 42%, #1a1a1a 46%, transparent 46%, transparent 54%, #1a1a1a 54%, #1a1a1a 58%, transparent 58%);
            pointer-events: none;
            mask: radial-gradient(circle at center, transparent 12%, black 12%);
            -webkit-mask: radial-gradient(circle at center, transparent 12%, black 12%);
            z-index: 0;
        }

        /* Center dot */
        .cell::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #1a1a1a;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0;
        }

        .cell:hover {
            background: #151515;
            border-color: #2a2a2a;
        }

        .cell:hover::before {
            background:
                linear-gradient(45deg, transparent 42%, #222 42%, #222 46%, transparent 46%, transparent 54%, #222 54%, #222 58%, transparent 58%),
                linear-gradient(-45deg, transparent 42%, #222 42%, #222 46%, transparent 46%, transparent 54%, #222 54%, #222 58%, transparent 58%);
        }

        .cell:hover::after {
            background: #222;
        }

        .cell.blocked {
            background: #1a1a1a;
            cursor: not-allowed;
            border-color: #222;
        }

        .cell.blocked::before {
            display: none;
        }

        .cell.blocked::after {
            width: 28px;
            height: 28px;
            background: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23333'%3E%3Cpath d='M12 1C8.676 1 6 3.676 6 7v2H4v14h16V9h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm-6 8h12v10H6V11z'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
        }

        /* Color Themes */
        .cell.green {
            --bg-color: #1a5c1a;
            --bg-alt: #0d3d0d;
            --border-color: #39ff14;
            --grid-line: 0 0 0 0 transparent; /* Hide grid line */
            border-color: transparent; /* Hide default grid border */
            z-index: 5;
        }
        .cell.blue {
            --bg-color: #0066a0;
            --bg-alt: #003d60;
            --border-color: #00bfff;
            --grid-line: 0 0 0 0 transparent;
            border-color: transparent;
            z-index: 5;
        }
        .cell.red {
            --bg-color: #8b1a1a;
            --bg-alt: #4d0f0f;
            --border-color: #ff3939;
            --grid-line: 0 0 0 0 transparent;
            border-color: transparent;
            z-index: 5;
        }
        .cell.purple {
            --bg-color: #5c1a8b;
            --bg-alt: #300d47;
            --border-color: #bf39ff;
            --grid-line: 0 0 0 0 transparent;
            border-color: transparent;
            z-index: 5;
        }
        
        /* Apply alternate shade if present */
        .cell.shade-alt {
            background: var(--bg-alt, var(--bg-color));
        }



        /* Hide pattern for colored cells */
        .cell.green::before,
        .cell.blue::before,
        .cell.red::before,
        .cell.purple::before {
            display: none;
        }

        /* Locked cells */
        .cell.locked-green {
            background: #1a5c1a;
            border: 2px dashed #39ff14;
            box-shadow: inset 0 0 15px rgba(57, 255, 20, 0.2);
        }

        .cell.locked-blue {
            background: #0066a0;
            border: 2px dashed #00bfff;
            box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.2);
        }

        .cell.locked-green::before,
        .cell.locked-blue::before,
        .cell.locked-red::before,
        .cell.locked-purple::before {
            display: none;
        }

        .cell.locked-green::after,
        .cell.locked-blue::after,
        .cell.locked-red::after,
        .cell.locked-purple::after {
            width: 16px;
            height: 16px;
            background: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='rgba(255,255,255,0.3)'%3E%3Cpath d='M12 1C8.676 1 6 3.676 6 7v2H4v14h16V9h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4z'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
        }

        .cell.locked-red {
            background: #8b1a1a;
            border: 2px dashed #ff3939;
            box-shadow: inset 0 0 15px rgba(255, 57, 57, 0.2);
        }

        .cell.locked-purple {
            background: #5c1a8b;
            border: 2px dashed #bf39ff;
            box-shadow: inset 0 0 15px rgba(191, 57, 255, 0.2);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 25px;
            justify-content: center;
        }

        /* Status Panel */
        .status-panel {
            margin-top: 20px;
            padding: 12px 20px;
            background: #0f0f0f;
            border-radius: 2px;
            text-align: center;
            font-size: 0.85rem;
            color: #555;
            border: 1px solid #1a1a1a;
        }

        .status-panel.success {
            background: #0a1a0a;
            color: #39ff14;
            border-color: #1a3a1a;
        }

        .status-panel.error {
            background: #1a0a0a;
            color: #f87171;
            border-color: #3a1a1a;
        }

        .status-panel.solving {
            background: #1a1a0a;
            color: #fbbf24;
            border-color: #3a3a1a;
        }

        /* Solutions Gallery */
        .solutions-section {
            margin-top: 25px;
            padding: 16px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #151515;
            display: none;
        }

        .solutions-section.visible {
            display: block;
        }

        .solutions-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .solution-thumbnail {
            padding: 6px;
            background: #111;
            border-radius: 2px;
            border: 2px solid #222;
            cursor: pointer;
            transition: all 0.2s;
        }

        .solution-thumbnail:hover {
            border-color: #444;
            background: #161616;
        }

        .solution-thumbnail.selected {
            border-color: #39ff14;
        }

        .solution-mini-grid {
            display: grid;
            gap: 0;
        }

        .solution-mini-cell {
            width: 8px;
            height: 8px;
            background: #222;
            border-radius: 0;
        }

        .solution-mini-cell.green {
            background: #39ff14;
        }

        .solution-mini-cell.blue {
            background: #00bfff;
        }

        .solution-mini-cell.red {
            background: #ff3939;
        }

        .solution-mini-cell.purple {
            background: #bf39ff;
        }

        .solution-mini-cell.blocked {
            background: #2a2a2a;
        }


        /* Instructions */
        .instructions {
            margin-top: 30px;
            padding: 16px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #151515;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .instructions h3 {
            font-size: 0.8rem;
            margin-bottom: 16px;
            color: #444;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .instructions ul {
            list-style: none;
            font-size: 0.85rem;
            color: #555;
            line-height: 2;
        }

        .instructions li {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .instructions li::before {
            content: 'â€”';
            color: #333;
            flex-shrink: 0;
        }

        /* Cell mode selector */
        .cell-mode-selector {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: #111;
            border-radius: 2px;
            border: 1px solid #222;
        }

        .cell-mode-label {
            font-size: 0.75rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 4px;
        }

        .cell-mode-btn {
            padding: 5px 10px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 2px;
            color: #666;
            cursor: pointer;
            transition: all 0.15s;
        }

        .cell-mode-btn:hover {
            background: #252525;
            color: #888;
        }

        .cell-mode-btn.active {
            background: #252525;
            color: #ccc;
            border-color: #444;
        }

        .cell-mode-btn.green.active {
            background: #1a3a1a;
            color: #39ff14;
            border-color: #2d5a2d;
        }

        .cell-mode-btn.blue.active {
            background: #1a2a4a;
            color: #00bfff;
            border-color: #2d4a7a;
        }

        .cell-mode-btn.red.active {
            background: #3a1a1a;
            color: #ff3939;
            border-color: #5a2d2d;
        }

        .cell-mode-btn.purple.active {
            background: #2a1a3a;
            color: #bf39ff;
            border-color: #4a2d5a;
        }

        /* Fit All Pieces checkbox */
        .fit-mode-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .fit-mode-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 14px;
            background: #111;
            border-radius: 2px;
            border: 1px solid #222;
            transition: all 0.2s;
        }

        .fit-mode-checkbox:hover {
            background: #161616;
            border-color: #333;
        }

        .fit-mode-checkbox.active {
            background: #1a2a1a;
            border-color: #2d5a2d;
        }

        .fit-mode-checkbox input {
            display: none;
        }

        .fit-mode-checkbox .checkbox-box {
            width: 18px;
            height: 18px;
            border: 2px solid #444;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .fit-mode-checkbox.active .checkbox-box {
            background: #39ff14;
            border-color: #39ff14;
        }

        .fit-mode-checkbox .checkbox-box svg {
            width: 12px;
            height: 12px;
            fill: #000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .fit-mode-checkbox.active .checkbox-box svg {
            opacity: 1;
        }

        .fit-mode-checkbox .checkbox-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.2s;
        }

        .fit-mode-checkbox.active .checkbox-label {
            color: #39ff14;
        }

        /* Fix: Strategic Z-Index Layering */
        /* "Future" borders (Right/Bottom) must be higher than "Past" borders 
           to prevent the next cell in the DOM from covering the previous cell's border. */
        
        /* Tier 1: Top/Left borders (Safe, naturally above previous neighbors) */
        .cell.border-top,
        .cell.border-left {
            z-index: 50 !important;
        }

        /* Tier 2: Bottom borders (Must be above the neighbor below) */
        .cell.border-bottom {
            z-index: 60 !important;
        }

        /* Tier 3: Right borders (Must be above the neighbor to the right) */
        .cell.border-right {
            z-index: 70 !important;
        }
        
        /* Tier 4: Corner case - Right + Bottom combined */
        .cell.border-right.border-bottom {
            z-index: 80 !important;
        }

        /* ============================================
           MOBILE SUPPORT - Device Detection & Toggle
           ============================================ */

        /* Mobile mode toggle - unobtrusive corner placement */
        .mobile-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            font-size: 11px;
            color: #888;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }

        .mobile-toggle:hover {
            background: rgba(40, 40, 40, 0.95);
            border-color: #555;
            color: #aaa;
        }

        .mobile-toggle-checkbox {
            width: 32px;
            height: 18px;
            appearance: none;
            background: #333;
            border-radius: 9px;
            position: relative;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .mobile-toggle-checkbox::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: #666;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .mobile-toggle-checkbox:checked {
            background: #39ff14;
        }

        .mobile-toggle-checkbox:checked::after {
            left: 16px;
            background: #1a5c1a;
        }

        .mobile-toggle-label {
            white-space: nowrap;
        }

        /* Mobile mode indicator */
        body.mobile-mode .mobile-toggle {
            border-color: #39ff14;
        }

        body.mobile-mode .mobile-toggle-label::after {
            content: ' (ON)';
            color: #39ff14;
        }

        /* Touch device auto-detected indicator */
        body.touch-device:not(.mobile-mode) .mobile-toggle-label::after {
            content: ' (Touch)';
            color: #00bfff;
        }

        /* ============================================
           BENCHMARK PANEL - Temporary Testing Infrastructure
           ============================================ */

        .benchmark-toggle {
            display: none; /* Hidden - development tool only */
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 9999;
            padding: 6px 10px;
            background: rgba(30, 30, 30, 0.9);
            border: 1px solid #ff6b35;
            border-radius: 6px;
            font-size: 11px;
            color: #ff6b35;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
        }

        .benchmark-toggle:hover {
            background: rgba(255, 107, 53, 0.2);
        }

        .benchmark-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            background: #1a1a1a;
            border: 2px solid #ff6b35;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .benchmark-panel.visible {
            display: block;
        }

        .benchmark-panel h2 {
            margin: 0 0 15px 0;
            color: #ff6b35;
            font-size: 1.3rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .benchmark-panel .close-btn {
            background: none;
            border: 1px solid #666;
            color: #888;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        .benchmark-panel .close-btn:hover {
            border-color: #ff3939;
            color: #ff3939;
        }

        .benchmark-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }

        .benchmark-controls label {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #aaa;
            font-size: 12px;
        }

        .benchmark-controls input[type="number"] {
            width: 60px;
            padding: 4px;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #fff;
            border-radius: 4px;
        }

        .benchmark-controls .btn {
            padding: 8px 16px;
        }

        .benchmark-results {
            font-family: monospace;
            font-size: 12px;
            line-height: 1.6;
        }

        .benchmark-results table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .benchmark-results th,
        .benchmark-results td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        .benchmark-results th {
            color: #39ff14;
            background: #252525;
        }

        .benchmark-results tr:hover {
            background: #252525;
        }

        .benchmark-results .difficulty-easy { color: #39ff14; }
        .benchmark-results .difficulty-medium { color: #00bfff; }
        .benchmark-results .difficulty-hard { color: #ff9f1c; }
        .benchmark-results .difficulty-expert { color: #ff3939; }
        .benchmark-results .difficulty-master { color: #bf39ff; }

        .benchmark-progress {
            padding: 10px;
            background: #252525;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .benchmark-progress-bar {
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .benchmark-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #39ff14, #00bfff);
            transition: width 0.2s ease;
        }

        /* ============================================
           MOBILE SUPPORT - CSS Custom Properties
           ============================================ */

        :root {
            /* Base values (desktop) */
            --cell-size-large: 68px;
            --cell-size-medium: 56px;
            --cell-size-small: 48px;
            --cell-size-tiny: 40px;

            /* Touch target minimum (44px Apple HIG) */
            --touch-target-min: 44px;

            /* Palette shape preview size */
            --palette-cell-size: 12px;

            /* Bar segment sizes */
            --bar-segment-width: 16px;
            --bar-segment-height: 16px;

            /* Spacing */
            --mobile-spacing: 8px;

            /* Ghost preview offset (above finger) */
            --ghost-offset-y: -60px;
        }

        /* ============================================
           MOBILE SUPPORT - Media Queries (Additive)
           ============================================ */

        /* Narrow screens (phones) - layout adjustments */
        @media (max-width: 768px) {
            body.mobile-mode .container,
            body.touch-device .container {
                padding: 10px;
                max-width: 100%;
            }

            body.mobile-mode h1,
            body.touch-device h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            body.mobile-mode .config-panel,
            body.touch-device .config-panel {
                flex-wrap: wrap;
                gap: 8px;
            }

            body.mobile-mode .puzzle-area,
            body.touch-device .puzzle-area {
                flex-direction: column;
                gap: 15px;
            }
        }

        /* Very narrow screens (small phones) */
        @media (max-width: 480px) {
            body.mobile-mode .mode-toggle,
            body.touch-device .mode-toggle {
                width: 100%;
            }

            body.mobile-mode .mode-toggle-btn,
            body.touch-device .mode-toggle-btn {
                flex: 1;
                padding: 10px;
            }
        }

        /* Coarse pointer (touch) - interaction adjustments */
        @media (pointer: coarse) {
            /* Ensure minimum touch target sizes */
            body.mobile-mode .btn,
            body.mobile-mode button,
            body.touch-device .btn,
            body.touch-device button {
                min-height: var(--touch-target-min);
                min-width: var(--touch-target-min);
            }

            /* Larger cell mode buttons for touch */
            body.mobile-mode .cell-mode-btn,
            body.touch-device .cell-mode-btn {
                min-width: 50px;
                padding: 8px 12px;
            }
        }

        /* No hover capability - remove hover-dependent styles */
        @media (hover: none) {
            body.mobile-mode .btn:hover,
            body.touch-device .btn:hover {
                /* Remove hover effects that won't work on touch */
                transform: none;
            }
        }

        /* ============================================
           MOBILE SUPPORT - Puzzle Mode Layout
           ============================================ */

        /* Puzzle container on mobile */
        @media (max-width: 768px) {
            body.mobile-mode .puzzle-container,
            body.touch-device .puzzle-container {
                flex-direction: column;
                gap: 15px;
            }

            body.mobile-mode .puzzle-main,
            body.touch-device .puzzle-main {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            body.mobile-mode .puzzle-grid-area,
            body.touch-device .puzzle-grid-area {
                order: 1;
            }

            body.mobile-mode .puzzle-shape-palette,
            body.touch-device .puzzle-shape-palette {
                order: 2;
                width: 100%;
                max-width: 100%;
            }

            body.mobile-mode .palette-shapes,
            body.touch-device .palette-shapes {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }

            body.mobile-mode .palette-shape,
            body.touch-device .palette-shape {
                padding: 8px;
                min-width: 50px;
                min-height: 50px;
            }

            body.mobile-mode .puzzle-actions,
            body.touch-device .puzzle-actions {
                order: 3;
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 8px;
            }

            body.mobile-mode .puzzle-actions .btn,
            body.touch-device .puzzle-actions .btn {
                flex: 1;
                min-width: 80px;
                max-width: 120px;
            }
        }

        /* Smaller puzzle config panel on mobile */
        @media (max-width: 768px) {
            body.mobile-mode #puzzleUI .config-panel,
            body.touch-device #puzzleUI .config-panel {
                flex-direction: column;
                align-items: stretch;
            }

            body.mobile-mode #puzzleUI .config-group,
            body.touch-device #puzzleUI .config-group {
                width: 100%;
            }

            body.mobile-mode #puzzleUI .config-group label,
            body.touch-device #puzzleUI .config-group label {
                display: block;
                margin-bottom: 4px;
            }

            body.mobile-mode #puzzleUI .config-group input,
            body.touch-device #puzzleUI .config-group input {
                width: 100%;
            }
        }

        /* Solver mode on mobile */
        @media (max-width: 768px) {
            body.mobile-mode #solverUI .puzzle-area,
            body.touch-device #solverUI .puzzle-area {
                flex-direction: column;
            }

            body.mobile-mode #solverUI .grid-wrapper,
            body.touch-device #solverUI .grid-wrapper {
                overflow-x: auto;
                max-width: 100%;
            }

            body.mobile-mode #solverUI .solutions-panel,
            body.touch-device #solverUI .solutions-panel {
                width: 100%;
                max-height: 300px;
                overflow-y: auto;
            }
        }

        /* Requirements bars on mobile - slightly larger for readability */
        @media (max-width: 480px) {
            body.mobile-mode .prescriptive-bar,
            body.touch-device .prescriptive-bar {
                min-width: 14px;
            }

            body.mobile-mode .prescriptive-segment,
            body.touch-device .prescriptive-segment {
                min-width: 14px;
                min-height: 14px;
            }

            body.mobile-mode .puzzle-row-req,
            body.touch-device .puzzle-row-req {
                width: 50px;
                padding-right: 4px;
            }

            body.mobile-mode .puzzle-col-req,
            body.touch-device .puzzle-col-req {
                padding-bottom: 4px;
            }
        }

        /* Hide mobile toggle label on very small screens */
        @media (max-width: 360px) {
            .mobile-toggle-label {
                display: none;
            }
            .mobile-toggle {
                padding: 6px;
            }
        }

        /* ============================================
           MOBILE SUPPORT - Touch-Specific UI Elements
           ============================================ */

        /* Mobile rotate button (appears during touch drag) */
        .mobile-rotate-btn {
            display: none;
            position: fixed;
            z-index: 10001;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #39ff14 0%, #1a5c1a 100%);
            border: 2px solid #39ff14;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(57, 255, 20, 0.4);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .mobile-rotate-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(57, 255, 20, 0.6);
        }

        .mobile-rotate-btn.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Mobile undo button (appears after removal) */
        .mobile-undo-btn {
            display: none;
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            padding: 12px 24px;
            background: linear-gradient(135deg, #ff6b35 0%, #8b3a1a 100%);
            border: 2px solid #ff6b35;
            border-radius: 25px;
            color: white;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.4);
            animation: slideUp 0.3s ease;
        }

        .mobile-undo-btn.visible {
            display: block;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Prevent scrolling during touch drag */
        body.touch-dragging {
            overflow: hidden;
            touch-action: none;
        }

        body.touch-dragging * {
            touch-action: none;
        }

        /* Touch-friendly palette shapes */
        body.mobile-mode .palette-shape,
        body.touch-device .palette-shape {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Touch feedback ripple effect */
        .touch-ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(57, 255, 20, 0.3);
            transform: scale(0);
            animation: ripple 0.4s ease-out;
            pointer-events: none;
        }

        @keyframes ripple {
            to {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* Long-press indicator */
        .long-press-indicator {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 3px solid transparent;
            border-radius: 4px;
            pointer-events: none;
            transition: border-color 0.1s ease;
        }

        .long-press-indicator.active {
            border-color: #ff3939;
            animation: longPressGlow 0.5s ease infinite;
        }

        @keyframes longPressGlow {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 57, 57, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 57, 57, 0.8); }
        }

        /* Floating shape during touch drag */
        .touch-floating-shape {
            position: fixed;
            z-index: 10000;
            pointer-events: none;
            opacity: 0.9;
            transition: transform 0.1s ease;
        }

        .touch-floating-shape.awaiting-action {
            pointer-events: auto;
            animation: floatPulse 1.5s ease-in-out infinite;
        }

        @keyframes floatPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Missing Piece Editor Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .modal-header h2 {
            margin: 0;
            color: #fff;
            font-size: 1.3rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .modal-close:hover {
            color: #fff;
        }

        .missing-piece-info {
            background: #252525;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 20px;
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.5;
        }

        .missing-piece-info strong {
            color: #39ff14;
        }

        .shape-editor-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #333;
            padding: 2px;
            border-radius: 4px;
            margin-bottom: 16px;
            aspect-ratio: 1;
            max-width: 320px;
            margin-left: auto;
            margin-right: auto;
        }

        .shape-editor-cell {
            aspect-ratio: 1;
            background: #1a1a1a;
            border: 1px solid #444;
            cursor: pointer;
            transition: background 0.1s, border-color 0.1s;
        }

        .shape-editor-cell:hover {
            border-color: #39ff14;
        }

        .shape-editor-cell.filled {
            background: #39ff14;
            border-color: #2db80e;
        }

        .shape-name-input {
            width: 100%;
            padding: 10px 12px;
            background: #252525;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 0.95rem;
            margin-bottom: 16px;
        }

        .shape-name-input:focus {
            outline: none;
            border-color: #39ff14;
        }

        .shape-name-input::placeholder {
            color: #666;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-buttons .btn {
            padding: 10px 20px;
        }

        .btn-save {
            background: #39ff14;
            color: #000;
        }

        .btn-save:hover {
            background: #2db80e;
        }

        .btn-exit {
            background: #444;
            color: #fff;
        }

        .btn-exit:hover {
            background: #555;
        }

        .custom-shapes-list {
            margin-top: 20px;
            border-top: 1px solid #333;
            padding-top: 16px;
        }

        .custom-shapes-list h3 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #888;
        }

        .custom-shape-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #252525;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .custom-shape-item .shape-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .custom-shape-preview {
            display: grid;
            gap: 1px;
            background: #333;
            padding: 2px;
            border-radius: 2px;
        }

        .custom-shape-preview .cell {
            width: 8px;
            height: 8px;
            background: #1a1a1a;
        }

        .custom-shape-preview .cell.filled {
            background: #39ff14;
        }

        .preview-container {
            display: flex;
            align-items: center;
        }

        .custom-shape-name {
            color: #fff;
            font-size: 0.9rem;
        }

        .custom-shape-cells {
            color: #888;
            font-size: 0.8rem;
        }

        .btn-delete-shape {
            background: #ff3939;
            color: #fff;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .btn-delete-shape:hover {
            background: #cc2e2e;
        }

        .btn-missing-piece {
            background: #333;
            color: #aaa;
            border: 1px solid #444;
            padding: 8px 16px;
            margin-top: 12px;
            font-size: 0.85rem;
        }

        .btn-missing-piece:hover {
            background: #444;
            color: #fff;
            border-color: #555;
        }

        .no-custom-shapes {
            color: #666;
            font-style: italic;
            font-size: 0.85rem;
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>

    <!-- Missing Piece Editor Modal -->
    <div class="modal-overlay" id="missingPieceModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Missing Piece Editor</h2>
                <button class="modal-close" onclick="closeMissingPieceEditor()">&times;</button>
            </div>

            <div class="missing-piece-info">
                <strong>Note:</strong> Custom shapes are saved to your browser's local storage.
                They will persist between page reloads, but only for <em>your</em> browser.<br><br>
                If you believe a shape is missing from the default set, please notify the author
                so it can be added for all users.
            </div>

            <input type="text" class="shape-name-input" id="customShapeName"
                   placeholder="Enter shape name (e.g., 'My Custom L')" maxlength="50">

            <div class="shape-editor-grid" id="shapeEditorGrid">
                <!-- 8x8 grid cells will be generated by JavaScript -->
            </div>

            <div class="modal-buttons">
                <button class="btn btn-exit" onclick="closeMissingPieceEditor()">Exit</button>
                <button class="btn btn-save" onclick="saveCustomShape()">Save Shape</button>
            </div>

            <div class="custom-shapes-list" id="customShapesList">
                <h3>Your Custom Shapes</h3>
                <div id="customShapesContainer">
                    <!-- Custom shapes will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Mode Toggle (unobtrusive, bottom-right corner) -->
    <label class="mobile-toggle" title="Force mobile mode for testing">
        <input type="checkbox" class="mobile-toggle-checkbox" id="mobileToggle" onchange="toggleMobileMode(this.checked)">
        <span class="mobile-toggle-label">Mobile</span>
    </label>

    <!-- Mobile-specific UI elements (hidden until needed) -->
    <button class="mobile-rotate-btn" id="mobileRotateBtn" title="Rotate shape">â†»</button>
    <button class="mobile-undo-btn" id="mobileUndoBtn">â†© Undo Removal</button>

    <!-- Benchmark Panel Toggle (bottom-left corner) -->
    <button class="benchmark-toggle" onclick="toggleBenchmarkPanel()">ðŸ“Š Benchmark</button>

    <!-- Benchmark Panel (hidden by default) -->
    <div class="benchmark-panel" id="benchmarkPanel">
        <h2>
            Difficulty Benchmark Tool
            <button class="close-btn" onclick="toggleBenchmarkPanel()">âœ• Close</button>
        </h2>
        <div class="benchmark-controls">
            <label>
                Mode:
                <select id="benchmarkMode" onchange="updateBenchmarkModeInfo()">
                    <option value="presets">Presets Only (5 configs)</option>
                    <option value="all">All Combinations (80 configs)</option>
                </select>
            </label>
            <label>
                Samples per config:
                <input type="number" id="benchmarkSamples" value="10" min="1" max="100">
            </label>
            <span id="benchmarkModeInfo" style="color: #666; font-size: 10px; margin-left: 5px;">(50 total puzzles)</span>
            <button class="btn btn-primary" onclick="runBenchmark()">Run Benchmark</button>
            <button class="btn" onclick="clearBenchmarkResults()">Clear Results</button>
        </div>
        <div class="benchmark-progress" id="benchmarkProgress" style="display: none;">
            <div>Running: <span id="benchmarkStatus">...</span></div>
            <div class="benchmark-progress-bar">
                <div class="benchmark-progress-fill" id="benchmarkProgressFill" style="width: 0%"></div>
            </div>
        </div>
        <div class="benchmark-results" id="benchmarkResults">
            <p style="color: #888;">Click "Run Benchmark" to generate puzzles at each difficulty and measure solver complexity.</p>
            <p style="color: #888; font-size: 11px;">This will generate puzzles, then solve them while measuring nodes explored and time taken.</p>
        </div>
    </div>

    <div class="container">
        <h1>Originium Circuitry Solver</h1>

        <!-- Mode Toggle -->
        <div class="mode-toggle-container">
            <div class="mode-toggle">
                <button class="mode-toggle-btn active" id="solverModeBtn" onclick="setMode('solver')">Solver</button>
                <button class="mode-toggle-btn" id="puzzleModeBtn" onclick="setMode('puzzle')">Puzzle</button>
            </div>
        </div>

        <!-- Solver Mode UI -->
        <div id="solverUI">

        <!-- Configuration Panel -->
        <div class="config-panel">
            <div class="config-group">
                <label>Rows</label>
                <input type="number" id="rowCount" min="2" max="10" value="5">
            </div>
            <div class="config-group">
                <label>Cols</label>
                <input type="number" id="colCount" min="2" max="10" value="5">
            </div>
            <button class="btn btn-primary" onclick="generateGrid()">Generate</button>

            <div class="cell-mode-selector">
                <span class="cell-mode-label">Place:</span>
                <button class="cell-mode-btn active" data-mode="none" onclick="setCellMode('none')">None</button>
                <button class="cell-mode-btn" data-mode="blocked" onclick="setCellMode('blocked')">Block</button>
                <button class="cell-mode-btn green" data-mode="locked-green" onclick="setCellMode('locked-green')">Green</button>
                <button class="cell-mode-btn blue" data-mode="locked-blue" onclick="setCellMode('locked-blue')">Blue</button>
            </div>

        </div>

        <!-- Puzzle Area -->
        <div class="puzzle-area">
            <!-- Shape Selector -->
            <div class="shape-selector" id="shapeSelector">
                <div class="shape-selector-title">Shapes</div>
                <div class="shape-selector-grid" id="shapeGrid"></div>
                <button class="hide-blue-btn" id="hideBlueBtn" onclick="toggleHideBlue()">Hide Blue</button>
                <button class="btn btn-missing-piece" onclick="openMissingPieceEditor()" style="width:100%; margin-top:8px;">Missing Piece?</button>
            </div>

            <div class="puzzle-wrapper">
                <!-- Column Requirements - above the grid -->
                <div class="col-requirements" id="colRequirementsWrapper">
                    <div class="col-req-spacer" id="colReqSpacer"></div>
                    <div class="col-requirements-inner" id="colRequirements" style="display:flex; gap:0;"></div>
                </div>

                <!-- Row with row requirements + grid -->
                <div class="grid-row">
                    <!-- Row Requirements - left of the grid -->
                    <div class="row-requirements" id="rowRequirements"></div>

                    <!-- Main Grid -->
                    <div class="grid" id="grid"></div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="btn btn-solve" onclick="solvePuzzle()">Solve</button>
                    <button class="btn btn-clear" onclick="clearGrid()">Clear</button>
                </div>

                <!-- Fit All Pieces Mode -->
                <div class="fit-mode-container">
                    <label class="fit-mode-checkbox" id="fitModeCheckbox" onclick="toggleFitMode()">
                        <div class="checkbox-box">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                        </div>
                        <span class="checkbox-label">Only Required To Fit All Pieces</span>
                    </label>
                </div>

                <!-- Input Mode Toggle -->
                <div class="input-mode-slider">
                    <div class="slider-toggle" onclick="toggleInputMode()">
                        <div class="slider-bg" id="sliderBg"></div>
                        <div class="slider-option" id="optionGrid" data-mode="bar">Grid</div>
                        <div class="slider-option" id="optionNumber" data-mode="stepper">Number</div>
                    </div>
                </div>

                <!-- Status Panel -->
                <div class="status-panel" id="statusPanel">
                    Set requirements for each row and column, then solve
                </div>
            </div>
        </div>

        <!-- Solutions Gallery -->
        <div class="solutions-section" id="solutionsSection">
            <h2>Solutions Found</h2>
            <div class="solutions-gallery" id="solutionsGallery"></div>
        </div>


        <!-- Instructions -->
        <div class="instructions">
            <h3>Instructions</h3>
            <ul>
                <li>Set grid dimensions and click Generate</li>
                <li>Use the arrows to set required green/blue cell counts per row/column</li>
                <li>Toggle "Block cells" mode and click cells to mark them as blocked</li>
                <li>Click Solve to find valid configurations using the defined shapes</li>
            </ul>
        </div>

        </div><!-- End Solver UI -->

        <!-- Puzzle Mode UI -->
        <div id="puzzleUI" style="display: none;">
            <div class="puzzle-config-panel">
                <h2>Puzzle Configuration</h2>

                <div class="puzzle-difficulty-selector">
                    <h3 class="difficulty-help">Difficulty <span class="help-btn" onclick="toggleDifficultyHelp(event)">?</span></h3>
                    <div class="help-tooltip" id="difficultyHelpTooltip">
                        <span class="help-q">Q: How is the difficulty calculated?</span><br><br>
                        A: The solver was run against every combination of grid size, number of colors, and blocker/lock configuration. Difficulty is a reflection of how much TIME it took the solver script to solve each puzzle type.<br><br>
                        If the preset difficulties do not align with your expectations or preferences, try the <strong>Custom Settings</strong> option below.
                    </div>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn" data-difficulty="easy" onclick="setDifficulty('easy')">Easy</button>
                        <button class="difficulty-btn active" data-difficulty="medium" onclick="setDifficulty('medium')">Medium</button>
                        <button class="difficulty-btn" data-difficulty="hard" onclick="setDifficulty('hard')">Hard</button>
                        <button class="difficulty-btn" data-difficulty="expert" onclick="setDifficulty('expert')">Expert</button>
                        <button class="difficulty-btn" data-difficulty="master" onclick="setDifficulty('master')">Master</button>
                    </div>
                    <div class="custom-mode-toggle">
                        <label>
                            <input type="checkbox" id="customModeToggle" onchange="toggleCustomMode()">
                            Use Custom Settings
                        </label>
                    </div>
                </div>

                <div class="puzzle-custom-config hidden" id="customSettingsPanel">
                    <h3>Custom Settings</h3>
                    <div class="custom-config-grid">
                        <div class="config-item">
                            <label>Grid Size</label>
                            <div class="size-inputs">
                                <input type="number" id="puzzleRows" min="4" max="10" value="5">
                                <span>x</span>
                                <input type="number" id="puzzleCols" min="4" max="10" value="5">
                            </div>
                        </div>
                        <div class="config-item">
                            <label>Colors</label>
                            <div class="color-toggles">
                                <label class="color-toggle green active"><input type="checkbox" checked onchange="togglePuzzleColor('green')"> Green</label>
                                <label class="color-toggle blue active"><input type="checkbox" checked onchange="togglePuzzleColor('blue')"> Blue</label>
                                <label class="color-toggle red"><input type="checkbox" onchange="togglePuzzleColor('red')"> Red</label>
                                <label class="color-toggle purple"><input type="checkbox" onchange="togglePuzzleColor('purple')"> Purple</label>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>Features</label>
                            <div class="feature-toggles">
                                <label class="feature-toggle"><input type="checkbox" id="enableBlockers" checked> Blockers</label>
                                <label class="feature-toggle"><input type="checkbox" id="enableLocks"> Locked Cells</label>
                            </div>
                        </div>
                    </div>
                </div>

                <button class="btn btn-generate-puzzle" id="generatePuzzleBtn" onclick="generatePuzzle()">Generate Puzzle</button>
                <button class="btn btn-missing-piece" onclick="openMissingPieceEditor()">Missing Piece?</button>
            </div>

            <div class="puzzle-play-area" id="puzzlePlayArea" style="display: none;">
                <!-- Puzzle grid and shape palette will be rendered here -->
            </div>
        </div><!-- End Puzzle UI -->

    </div>

    <script src="shapes.js"></script>
    <script src="solver.js"></script>
    <script src="puzzle-generator.js"></script>
    <script>
        // SVG icons
        const upArrow = `<svg viewBox="0 0 24 24"><path d="M7 14l5-5 5 5z"/></svg>`;
        const downArrow = `<svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>`;

        let currentMode = 'solver'; // 'solver' or 'puzzle'
        let cellMode = 'none'; // 'none', 'blocked', 'locked-green', 'locked-blue', 'locked-red', 'locked-purple'

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        let barInputMode = true; // Default to bar/grid mode
        let gridState = [];
        let requirements = { rows: [], cols: [] };
        let rows = 5;
        let cols = 5;
        let shapeCounts = new Map(); // Track shape ID -> count for solving
        let fitAllPiecesMode = false; // When true, ignore requirements, just fit all pieces
        let hideBlue = false; // When true, hide blue inputs and center green
        let enabledColors = ['green', 'blue']; // Colors enabled for current puzzle
        const ALL_COLORS = ['green', 'blue', 'red', 'purple'];

        // ============================================
        // MOBILE SUPPORT - Device Detection
        // ============================================

        const DeviceCapabilities = {
            // Primary touch detection
            hasTouch: ('ontouchstart' in window) || (navigator.maxTouchPoints > 0),

            // Pointer events support (unified API)
            hasPointerEvents: 'PointerEvent' in window,

            // Screen size detection via matchMedia
            isNarrowScreen: () => window.matchMedia('(max-width: 768px)').matches,

            // Coarse pointer (finger) vs fine pointer (mouse)
            hasCoarsePointer: () => window.matchMedia('(pointer: coarse)').matches,

            // Hover capability
            canHover: () => window.matchMedia('(hover: hover)').matches,

            // Check if we're in mobile mode (forced or auto-detected)
            isMobileMode: () => document.body.classList.contains('mobile-mode'),

            // Check if touch device (auto-detected)
            isTouchDevice: () => document.body.classList.contains('touch-device')
        };

        // Mobile mode state
        let mobileMode = false;

        // Initialize device detection on load
        function initDeviceDetection() {
            // Auto-detect touch device
            if (DeviceCapabilities.hasTouch || DeviceCapabilities.hasCoarsePointer()) {
                document.body.classList.add('touch-device');
                console.log('Touch device detected');
            }

            // Check for saved mobile mode preference
            const savedMobileMode = localStorage.getItem('forceMobileMode');
            if (savedMobileMode === 'true') {
                toggleMobileMode(true);
                document.getElementById('mobileToggle').checked = true;
            }

            // Log device capabilities
            console.log('Device Capabilities:', {
                hasTouch: DeviceCapabilities.hasTouch,
                hasPointerEvents: DeviceCapabilities.hasPointerEvents,
                isNarrowScreen: DeviceCapabilities.isNarrowScreen(),
                hasCoarsePointer: DeviceCapabilities.hasCoarsePointer(),
                canHover: DeviceCapabilities.canHover()
            });
        }

        // Toggle mobile mode (for testing or as failsafe)
        function toggleMobileMode(enabled) {
            mobileMode = enabled;

            if (enabled) {
                document.body.classList.add('mobile-mode');
                showToast('Mobile mode enabled', 'info', 2000);
            } else {
                document.body.classList.remove('mobile-mode');
                showToast('Mobile mode disabled', 'info', 2000);
            }

            // Save preference
            localStorage.setItem('forceMobileMode', enabled.toString());

            // Trigger any mobile-specific initialization
            if (enabled) {
                initMobileInteractions();
            } else {
                cleanupMobileInteractions();
            }
        }

        // Placeholder for mobile interaction initialization
        function initMobileInteractions() {
            console.log('Mobile interactions initialized');
            // Will be implemented in subsequent tasks
        }

        // Placeholder for mobile interaction cleanup
        function cleanupMobileInteractions() {
            console.log('Mobile interactions cleaned up');
            // Will be implemented in subsequent tasks
        }

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            initDeviceDetection();
            initGlobalTouchHandlers();
        });

        // Set up global touch handlers (always active, they check mode internally)
        function initGlobalTouchHandlers() {
            document.addEventListener('touchmove', handleTouchDragMove, { passive: false });
            document.addEventListener('touchend', handleTouchDragEnd);

            // Initialize rotate button handlers
            const rotateBtn = document.getElementById('mobileRotateBtn');
            if (rotateBtn) {
                rotateBtn.addEventListener('click', handleMobileRotate);
                rotateBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    handleMobileRotate();
                });
            }
        }

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('solverModeBtn').classList.toggle('active', mode === 'solver');
            document.getElementById('puzzleModeBtn').classList.toggle('active', mode === 'puzzle');

            // Show/hide mode-specific UI
            document.getElementById('solverUI').style.display = mode === 'solver' ? 'block' : 'none';
            document.getElementById('puzzleUI').style.display = mode === 'puzzle' ? 'block' : 'none';

            if (mode === 'puzzle') {
                initPuzzleMode();
            }
        }

        function setCellMode(mode) {
            cellMode = mode;
            document.querySelectorAll('.cell-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
        }

        function toggleFitMode() {
            fitAllPiecesMode = !fitAllPiecesMode;
            const checkbox = document.getElementById('fitModeCheckbox');
            checkbox.classList.toggle('active', fitAllPiecesMode);
        }

        function toggleHideBlue() {
            hideBlue = !hideBlue;
            const btn = document.getElementById('hideBlueBtn');
            btn.classList.toggle('active', hideBlue);
            btn.textContent = hideBlue ? 'Show Blue' : 'Hide Blue';
            regenerateInputs();
        }

        function toggleInputMode() {
            barInputMode = !barInputMode;
            updateSliderToggle();
            regenerateInputs();
        }

        function updateSliderToggle() {
            const gridOption = document.getElementById('optionGrid');
            const numberOption = document.getElementById('optionNumber');
            const sliderBg = document.getElementById('sliderBg');

            if (barInputMode) {
                gridOption.classList.add('active');
                numberOption.classList.remove('active');
                sliderBg.style.width = gridOption.offsetWidth + 'px';
                sliderBg.style.left = '4px';
            } else {
                gridOption.classList.remove('active');
                numberOption.classList.add('active');
                sliderBg.style.width = numberOption.offsetWidth + 'px';
                sliderBg.style.left = (gridOption.offsetWidth + 4) + 'px';
            }
        }

        function regenerateInputs() {
            // Regenerate column requirements (green left, blue right)
            const colReqs = document.getElementById('colRequirements');
            colReqs.innerHTML = '';
            for (let c = 0; c < cols; c++) {
                const colReq = document.createElement('div');
                colReq.className = 'col-req';
                if (barInputMode) {
                    colReq.appendChild(createBarInput('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createBarInput('blue', 'col', c, rows));
                    }
                } else {
                    colReq.appendChild(createStepper('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createStepper('blue', 'col', c, rows));
                    }
                }
                colReqs.appendChild(colReq);
            }

            // Regenerate row requirements (blue on top, green on bottom)
            const rowReqs = document.getElementById('rowRequirements');
            rowReqs.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                const rowReq = document.createElement('div');
                rowReq.className = 'row-req';
                if (barInputMode) {
                    if (!hideBlue) {
                        rowReq.appendChild(createBarInput('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createBarInput('green', 'row', r, cols));
                } else {
                    if (!hideBlue) {
                        rowReq.appendChild(createStepper('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createStepper('green', 'row', r, cols));
                }
                rowReqs.appendChild(rowReq);
            }

            // Update spacer to match row requirements width
            const spacer = document.getElementById('colReqSpacer');
            spacer.style.width = '60px';
        }

        function createBarInput(color, type, index, max) {
            const container = document.createElement('div');
            container.className = `bar-input ${color}`;
            container.dataset.type = type;
            container.dataset.index = index;
            container.dataset.color = color;
            container.dataset.max = max;
            container.dataset.value = requirements[type === 'col' ? 'cols' : 'rows'][index]?.[color] || 0;

            for (let i = 1; i <= max; i++) {
                const segment = document.createElement('div');
                segment.className = 'bar-segment';
                segment.dataset.level = i;

                if (type === 'col') {
                    // Column inputs: vertical bars, segments stack vertically
                    const segmentHeight = Math.floor((60 - (max - 1) * 1) / max);
                    segment.style.height = segmentHeight + 'px';
                    segment.style.width = '100%';
                } else {
                    // Row inputs: horizontal bars, segments stack horizontally
                    const segmentWidth = Math.floor((60 - (max - 1) * 1) / max);
                    segment.style.width = segmentWidth + 'px';
                    segment.style.height = '100%';
                }

                const currentValue = parseInt(container.dataset.value) || 0;
                if (i <= currentValue) {
                    segment.classList.add('filled');
                }

                segment.onclick = (e) => {
                    e.stopPropagation();
                    handleBarClick(container, i);
                };

                container.appendChild(segment);
            }

            return container;
        }

        function handleBarClick(container, level) {
            const type = container.dataset.type;
            const index = parseInt(container.dataset.index);
            const color = container.dataset.color;
            const currentValue = parseInt(container.dataset.value) || 0;

            // If clicking the same level that's already set, clear it (set to level - 1)
            // Otherwise set to clicked level
            let newValue;
            if (currentValue === level) {
                newValue = level - 1;
            } else {
                newValue = level;
            }

            container.dataset.value = newValue;

            // Update visual state
            const segments = container.querySelectorAll('.bar-segment');
            segments.forEach(seg => {
                const segLevel = parseInt(seg.dataset.level);
                seg.classList.toggle('filled', segLevel <= newValue);
            });

            // Update requirements
            if (type === 'col') {
                requirements.cols[index][color] = newValue;
            } else {
                requirements.rows[index][color] = newValue;
            }
        }

        function createStepper(color, type, index, max) {
            const stepper = document.createElement('div');
            stepper.className = `stepper ${color}`;
            stepper.dataset.type = type;
            stepper.dataset.index = index;
            stepper.dataset.color = color;

            const upBtn = document.createElement('div');
            upBtn.className = 'stepper-btn up';
            upBtn.innerHTML = upArrow;
            upBtn.onclick = (e) => {
                e.stopPropagation();
                adjustValue(stepper, 1, max);
            };

            const valueDisplay = document.createElement('div');
            valueDisplay.className = 'stepper-value';
            valueDisplay.textContent = '0';

            const downBtn = document.createElement('div');
            downBtn.className = 'stepper-btn down';
            downBtn.innerHTML = downArrow;
            downBtn.onclick = (e) => {
                e.stopPropagation();
                adjustValue(stepper, -1, max);
            };

            stepper.appendChild(upBtn);
            stepper.appendChild(valueDisplay);
            stepper.appendChild(downBtn);

            return stepper;
        }

        function adjustValue(stepper, delta, max) {
            const valueEl = stepper.querySelector('.stepper-value');
            let val = parseInt(valueEl.textContent) || 0;
            val = Math.max(0, Math.min(max, val + delta));
            valueEl.textContent = val;

            const type = stepper.dataset.type;
            const index = parseInt(stepper.dataset.index);
            const color = stepper.dataset.color;

            if (type === 'col') {
                requirements.cols[index][color] = val;
            } else {
                requirements.rows[index][color] = val;
            }
        }

        function generateGrid() {
            rows = parseInt(document.getElementById('rowCount').value) || 5;
            cols = parseInt(document.getElementById('colCount').value) || 5;
            rows = Math.max(2, Math.min(10, rows));
            cols = Math.max(2, Math.min(10, cols));

            gridState = Array(rows).fill(null).map(() => Array(cols).fill('empty'));
            requirements = {
                rows: Array(rows).fill(null).map(() => ({ green: 0, blue: 0 })),
                cols: Array(cols).fill(null).map(() => ({ green: 0, blue: 0 }))
            };

            const grid = document.getElementById('grid');
            grid.style.gridTemplateColumns = `repeat(${cols}, 68px)`;
            grid.innerHTML = '';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.onclick = () => handleCellClick(r, c, cell);
                    grid.appendChild(cell);
                }
            }

            // Column requirements (green left, blue right)
            const colReqs = document.getElementById('colRequirements');
            colReqs.innerHTML = '';
            for (let c = 0; c < cols; c++) {
                const colReq = document.createElement('div');
                colReq.className = 'col-req';
                if (barInputMode) {
                    colReq.appendChild(createBarInput('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createBarInput('blue', 'col', c, rows));
                    }
                } else {
                    colReq.appendChild(createStepper('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createStepper('blue', 'col', c, rows));
                    }
                }
                colReqs.appendChild(colReq);
            }

            const spacer = document.getElementById('colReqSpacer');
            spacer.style.width = '60px';

            // Row requirements (blue on top, green on bottom)
            const rowReqs = document.getElementById('rowRequirements');
            rowReqs.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                const rowReq = document.createElement('div');
                rowReq.className = 'row-req';
                if (barInputMode) {
                    if (!hideBlue) {
                        rowReq.appendChild(createBarInput('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createBarInput('green', 'row', r, cols));
                } else {
                    if (!hideBlue) {
                        rowReq.appendChild(createStepper('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createStepper('green', 'row', r, cols));
                }
                rowReqs.appendChild(rowReq);
            }

            // Hide solutions
            document.getElementById('solutionsSection').classList.remove('visible');

            updateStatus('Ready');
        }

        function handleCellClick(r, c, cellElement) {
            if (cellMode === 'none') return;

            const current = gridState[r][c];

            // Toggle: if clicking same type, clear it; otherwise set to new type
            if (current === cellMode) {
                gridState[r][c] = 'empty';
            } else {
                gridState[r][c] = cellMode;
            }

            updateCellDisplay(cellElement, gridState[r][c]);
        }

        function updateCellDisplay(cell, state) {
            // Preserve only base 'cell' class, remove all state classes
            cell.className = 'cell';
            if (state && state !== 'empty') {
                cell.classList.add(state);
            }
        }

        function clearGrid() {
            gridState = Array(rows).fill(null).map(() => Array(cols).fill('empty'));
            document.querySelectorAll('#grid .cell').forEach(cell => {
                cell.className = 'cell';
            });

            // Reset requirements
            requirements = {
                rows: Array(rows).fill(null).map(() => ({ green: 0, blue: 0 })),
                cols: Array(cols).fill(null).map(() => ({ green: 0, blue: 0 }))
            };

            // Clear shape selections
            shapeCounts.clear();
            document.querySelectorAll('.shape-selector-item').forEach(item => {
                item.classList.remove('active');
                const badge = item.querySelector('.shape-count-badge');
                if (badge) badge.textContent = '1';
            });

            // Regenerate inputs to reset their visual state
            regenerateInputs();

            currentSolutions = [];
            selectedSolutionIndex = -1;
            document.getElementById('solutionsSection').classList.remove('visible');
            updateStatus('Grid cleared');
        }

        function clearSolutionOnly() {
            // Clear just the solution display, keeping locked/blocked cells
            document.querySelectorAll('#grid .cell').forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                updateCellDisplay(cell, gridState[r][c]);
            });
            currentSolutions = [];
            selectedSolutionIndex = -1;
            document.getElementById('solutionsSection').classList.remove('visible');
            updateStatus('Ready');
        }

        let currentSolutions = [];
        let selectedSolutionIndex = -1;

        function solvePuzzle() {
            if (shapeCounts.size === 0) {
                updateStatus('Please select at least one shape from the left panel', 'error');
                return;
            }

            updateStatus('Solving...', 'solving');

            // Get blocked cells
            const blockedCells = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (gridState[r][c] === 'blocked' || gridState[r][c] === 'locked-green' || gridState[r][c] === 'locked-blue') {
                        blockedCells.push([r, c]);
                    }
                }
            }

            // Convert shapeCounts map to object
            const shapeCountsObj = Object.fromEntries(shapeCounts);

            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                try {
                    let result;

                    if (fitAllPiecesMode) {
                        // Just fit all pieces, ignore row/column requirements
                        result = runFitAllPiecesSolver(rows, cols, blockedCells, shapeCountsObj);
                    } else {
                        // Calculate locked cell contributions and adjusted requirements
                        const lockedGreenCounts = { rows: Array(rows).fill(0), cols: Array(cols).fill(0) };
                        const lockedBlueCounts = { rows: Array(rows).fill(0), cols: Array(cols).fill(0) };

                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                if (gridState[r][c] === 'locked-green') {
                                    lockedGreenCounts.rows[r]++;
                                    lockedGreenCounts.cols[c]++;
                                } else if (gridState[r][c] === 'locked-blue') {
                                    lockedBlueCounts.rows[r]++;
                                    lockedBlueCounts.cols[c]++;
                                }
                            }
                        }

                        // Create adjusted requirements (subtract locked cell contributions)
                        const adjustedRowReqs = requirements.rows.map((req, r) => ({
                            green: Math.max(0, req.green - lockedGreenCounts.rows[r]),
                            blue: Math.max(0, req.blue - lockedBlueCounts.rows[r])
                        }));
                        const adjustedColReqs = requirements.cols.map((req, c) => ({
                            green: Math.max(0, req.green - lockedGreenCounts.cols[c]),
                            blue: Math.max(0, req.blue - lockedBlueCounts.cols[c])
                        }));

                        // Check for over-constrained (locked cells exceed requirements)
                        let overConstrained = false;
                        for (let r = 0; r < rows; r++) {
                            if (lockedGreenCounts.rows[r] > requirements.rows[r].green) {
                                updateStatus(`Row ${r + 1}: locked green cells exceed requirement`, 'error');
                                overConstrained = true;
                                break;
                            }
                            if (lockedBlueCounts.rows[r] > requirements.rows[r].blue) {
                                updateStatus(`Row ${r + 1}: locked blue cells exceed requirement`, 'error');
                                overConstrained = true;
                                break;
                            }
                        }
                        if (!overConstrained) {
                            for (let c = 0; c < cols; c++) {
                                if (lockedGreenCounts.cols[c] > requirements.cols[c].green) {
                                    updateStatus(`Column ${c + 1}: locked green cells exceed requirement`, 'error');
                                    overConstrained = true;
                                    break;
                                }
                                if (lockedBlueCounts.cols[c] > requirements.cols[c].blue) {
                                    updateStatus(`Column ${c + 1}: locked blue cells exceed requirement`, 'error');
                                    overConstrained = true;
                                    break;
                                }
                            }
                        }
                        if (overConstrained) return;

                        // Create modified grid state where locked cells are treated as blocked
                        const modifiedGridState = gridState.map(row => row.map(cell => {
                            if (cell === 'locked-green' || cell === 'locked-blue') {
                                return 'blocked';
                            }
                            return cell;
                        }));

                        result = runSolverWithShapeCounts(
                            rows, cols, modifiedGridState, adjustedRowReqs, adjustedColReqs, shapeCountsObj
                        );

                        // Check if adjusted requirements are all zero (solved by locked cells alone)
                        if (!result.success) {
                            const allZero = adjustedRowReqs.every(r => r.green === 0 && r.blue === 0) &&
                                           adjustedColReqs.every(c => c.green === 0 && c.blue === 0);
                            if (allZero) {
                                result = {
                                    success: true,
                                    solutions: [{ green: [], blue: [], greenPlacements: [], bluePlacements: [] }]
                                };
                                updateStatus('Solved by locked cells alone', 'success');
                            }
                        }
                    }

                    if (result.success) {
                        currentSolutions = result.solutions;
                        updateStatus(`Found ${result.solutions.length} solution${result.solutions.length > 1 ? 's' : ''}`, 'success');
                        displaySolutions(result.solutions);

                        // Auto-apply first solution
                        if (result.solutions.length > 0) {
                            applySolution(0);
                        }
                    } else {
                        currentSolutions = [];
                        updateStatus(result.message, 'error');
                        document.getElementById('solutionsSection').classList.remove('visible');
                    }
                } catch (e) {
                    console.error('Solver error:', e);
                    updateStatus('Solver error: ' + e.message, 'error');
                }
            }, 50);
        }

        function displaySolutions(solutions) {
            const section = document.getElementById('solutionsSection');
            const gallery = document.getElementById('solutionsGallery');
            gallery.innerHTML = '';

            solutions.forEach((solution, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'solution-thumbnail';
                thumb.dataset.index = index;
                thumb.onclick = () => applySolution(index);

                const miniGrid = document.createElement('div');
                miniGrid.className = 'solution-mini-grid';
                miniGrid.style.gridTemplateColumns = `repeat(${cols}, 8px)`;

                // Create cell lookup sets
                const greenSet = new Set(solution.green.map(([r, c]) => `${r},${c}`));
                const blueSet = new Set(solution.blue.map(([r, c]) => `${r},${c}`));

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'solution-mini-cell';

                        const key = `${r},${c}`;
                        const cellState = gridState[r][c];

                        if (cellState === 'blocked') {
                            cell.classList.add('blocked');
                        } else if (cellState === 'locked-green' || greenSet.has(key)) {
                            cell.classList.add('green');
                        } else if (cellState === 'locked-blue' || blueSet.has(key)) {
                            cell.classList.add('blue');
                        }

                        miniGrid.appendChild(cell);
                    }
                }

                thumb.appendChild(miniGrid);
                gallery.appendChild(thumb);
            });

            section.classList.add('visible');
        }

        function applySolution(index) {
            selectedSolutionIndex = index;
            const solution = currentSolutions[index];

            // Update thumbnail selection
            document.querySelectorAll('.solution-thumbnail').forEach((thumb, i) => {
                thumb.classList.toggle('selected', i === index);
            });

            // Build maps for cell -> shape membership and neighbors
            const cellShapeMap = new Map(); // key -> { color, shapeIndex, cells }

            // Process green placements
            if (solution.greenPlacements) {
                solution.greenPlacements.forEach((placement, shapeIdx) => {
                    const cellSet = new Set(placement.cells.map(([r, c]) => `${r},${c}`));
                    placement.cells.forEach(([r, c], cellIdx) => {
                        cellShapeMap.set(`${r},${c}`, {
                            color: 'green',
                            shapeIndex: shapeIdx,
                            cellIndex: cellIdx,
                            cellSet: cellSet
                        });
                    });
                });
            }

            // Process blue placements
            if (solution.bluePlacements) {
                solution.bluePlacements.forEach((placement, shapeIdx) => {
                    const cellSet = new Set(placement.cells.map(([r, c]) => `${r},${c}`));
                    placement.cells.forEach(([r, c], cellIdx) => {
                        cellShapeMap.set(`${r},${c}`, {
                            color: 'blue',
                            shapeIndex: shapeIdx,
                            cellIndex: cellIdx,
                            cellSet: cellSet
                        });
                    });
                });
            }

            // Update main grid
            document.querySelectorAll('#grid .cell').forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const key = `${r},${c}`;

                // Reset classes and inline styles
                cell.className = 'cell';

                const cellState = gridState[r][c];

                if (cellState === 'blocked') {
                    cell.classList.add('blocked');
                } else if (cellState === 'locked-green') {
                    cell.classList.add('locked-green');
                } else if (cellState === 'locked-blue') {
                    cell.classList.add('locked-blue');
                } else if (cellShapeMap.has(key)) {
                    const info = cellShapeMap.get(key);
                    cell.classList.add(info.color);

                    // Alternating shade based on checkerboard pattern (row + col parity)
                    if ((r + c) % 2 === 1) {
                        cell.classList.add('shade-alt');
                    }

                    // Check neighbors for border edges
                    const topKey = `${r - 1},${c}`;
                    const rightKey = `${r},${c + 1}`;
                    const bottomKey = `${r + 1},${c}`;
                    const leftKey = `${r},${c - 1}`;

                    const hasTop = !info.cellSet.has(topKey);
                    const hasRight = !info.cellSet.has(rightKey);
                    const hasBottom = !info.cellSet.has(bottomKey);
                    const hasLeft = !info.cellSet.has(leftKey);

                    // Add border if neighbor is not part of same shape
                    if (hasTop) cell.classList.add('border-top');
                    if (hasRight) cell.classList.add('border-right');
                    if (hasBottom) cell.classList.add('border-bottom');
                    if (hasLeft) cell.classList.add('border-left');
                }
            });
        }

        function updateStatus(message, type = '') {
            const panel = document.getElementById('statusPanel');
            panel.textContent = message;
            panel.className = 'status-panel';
            if (type) panel.classList.add(type);
        }

        // Render shape selector (left panel)
        function renderShapeSelector() {
            const grid = document.getElementById('shapeGrid');
            grid.innerHTML = '';

            for (const [id, shape] of Object.entries(SHAPE_LIBRARY)) {
                const item = document.createElement('div');
                item.className = 'shape-selector-item';
                item.dataset.shapeId = id;
                item.title = `${shape.name} (click: +1, right-click or shift+click: -1)`;

                const baseShape = shape.rotations[0];
                const bounds = getShapeBounds(baseShape);

                const miniGrid = document.createElement('div');
                miniGrid.className = 'shape-mini-grid';
                miniGrid.style.gridTemplateColumns = `repeat(${bounds.width}, 10px)`;

                const cellSet = new Set(baseShape.map(([r, c]) => `${r},${c}`));

                for (let r = 0; r < bounds.height; r++) {
                    for (let c = 0; c < bounds.width; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'shape-mini-cell';
                        if (cellSet.has(`${r},${c}`)) {
                            cell.classList.add('filled');
                        }
                        miniGrid.appendChild(cell);
                    }
                }

                item.appendChild(miniGrid);

                const badge = document.createElement('div');
                badge.className = 'shape-count-badge';
                badge.textContent = '1';
                item.appendChild(badge);

                item.onclick = (e) => handleShapeClick(id, item, e, false);
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    handleShapeClick(id, item, e, true);
                };

                grid.appendChild(item);
            }
        }

        function handleShapeClick(shapeId, element, event, isRightClick = false) {
            if (event.preventDefault) event.preventDefault();

            const currentCount = shapeCounts.get(shapeId) || 0;
            let newCount;

            if (isRightClick || event.shiftKey) {
                // Right-click or shift+click: decrement
                newCount = Math.max(0, currentCount - 1);
            } else {
                // Left-click: increment
                newCount = currentCount + 1;
            }

            if (newCount === 0) {
                shapeCounts.delete(shapeId);
                element.classList.remove('active');
            } else {
                shapeCounts.set(shapeId, newCount);
                element.classList.add('active');
            }

            // Update badge
            const badge = element.querySelector('.shape-count-badge');
            if (badge) {
                badge.textContent = newCount || '';
            }

            console.log('Shape counts:', Object.fromEntries(shapeCounts));
        }

        // Puzzle Mode Functions

        // Difficulty pools based on benchmark data
        // Each config: { gridRows, gridCols, colors, blockers, locks }
        const DIFFICULTY_POOLS = {
            easy: [
                { gridRows: 4, gridCols: 4, colors: ['green'], blockers: true, locks: true },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue', 'red'], blockers: true, locks: true },
                { gridRows: 4, gridCols: 4, colors: ['green'], blockers: false, locks: true },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue'], blockers: false, locks: true },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue'], blockers: true, locks: false },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue'], blockers: true, locks: true },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue', 'red'], blockers: false, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red'], blockers: true, locks: false },
                { gridRows: 4, gridCols: 4, colors: ['green'], blockers: true, locks: false },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue', 'red'], blockers: true, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red'], blockers: true, locks: true }
            ],
            medium: [
                { gridRows: 5, gridCols: 5, colors: ['green'], blockers: true, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green'], blockers: true, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red'], blockers: true, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: false },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue'], blockers: false, locks: false },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red'], blockers: true, locks: false },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue'], blockers: true, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue'], blockers: true, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: false },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue'], blockers: true, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red'], blockers: false, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: true },
                { gridRows: 4, gridCols: 4, colors: ['green', 'blue', 'red'], blockers: false, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue'], blockers: false, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: true }
            ],
            hard: [
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red'], blockers: false, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red'], blockers: true, locks: true },
                { gridRows: 8, gridCols: 8, colors: ['green'], blockers: true, locks: false },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red'], blockers: false, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue'], blockers: false, locks: false },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue'], blockers: true, locks: false },
                { gridRows: 4, gridCols: 4, colors: ['green'], blockers: false, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: true },
                { gridRows: 5, gridCols: 5, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green'], blockers: false, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red'], blockers: false, locks: true }
            ],
            expert: [
                { gridRows: 6, gridCols: 6, colors: ['green'], blockers: false, locks: false },
                { gridRows: 6, gridCols: 6, colors: ['green'], blockers: false, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue'], blockers: false, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue'], blockers: true, locks: true },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue'], blockers: true, locks: false },
                { gridRows: 5, gridCols: 5, colors: ['green'], blockers: false, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green'], blockers: false, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green'], blockers: true, locks: true },
                { gridRows: 8, gridCols: 8, colors: ['green'], blockers: true, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red'], blockers: true, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green'], blockers: true, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue'], blockers: false, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: false },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: true },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue'], blockers: false, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green'], blockers: true, locks: false },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: false },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue'], blockers: false, locks: true },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red', 'purple'], blockers: false, locks: true },
                { gridRows: 6, gridCols: 6, colors: ['green', 'blue', 'red'], blockers: false, locks: false }
            ],
            master: [
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue'], blockers: true, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red'], blockers: false, locks: false },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue'], blockers: true, locks: false },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red'], blockers: false, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green'], blockers: true, locks: false },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red'], blockers: true, locks: false },
                { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red'], blockers: true, locks: true },
                { gridRows: 7, gridCols: 7, colors: ['green', 'blue'], blockers: false, locks: false },
                { gridRows: 8, gridCols: 8, colors: ['green'], blockers: false, locks: true }
            ]
        };

        let puzzleConfig = {
            difficulty: 'medium',
            useCustom: false,
            gridRows: 5,
            gridCols: 5,
            colors: ['green', 'blue'],
            blockers: true,
            locks: false
        };

        let currentPuzzle = null;

        function initPuzzleMode() {
            console.log('Puzzle mode initialized');
        }

        function toggleDifficultyHelp(event) {
            event.stopPropagation();
            const tooltip = document.getElementById('difficultyHelpTooltip');
            tooltip.classList.toggle('visible');

            // Close on click outside
            if (tooltip.classList.contains('visible')) {
                setTimeout(() => {
                    document.addEventListener('click', closeDifficultyHelp);
                }, 0);
            }
        }

        function closeDifficultyHelp() {
            const tooltip = document.getElementById('difficultyHelpTooltip');
            tooltip.classList.remove('visible');
            document.removeEventListener('click', closeDifficultyHelp);
        }

        // ============================================
        // MISSING PIECE EDITOR
        // ============================================

        let shapeEditorState = [];  // 8x8 grid state

        function openMissingPieceEditor() {
            // Initialize 8x8 grid state
            shapeEditorState = Array(8).fill(null).map(() => Array(8).fill(false));

            // Build the grid
            const grid = document.getElementById('shapeEditorGrid');
            grid.innerHTML = '';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'shape-editor-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', () => toggleShapeEditorCell(r, c));
                    grid.appendChild(cell);
                }
            }

            // Clear name input
            document.getElementById('customShapeName').value = '';

            // Load and display existing custom shapes
            renderCustomShapesList();

            // Show modal
            document.getElementById('missingPieceModal').classList.add('visible');
        }

        function closeMissingPieceEditor() {
            document.getElementById('missingPieceModal').classList.remove('visible');
        }

        function toggleShapeEditorCell(row, col) {
            shapeEditorState[row][col] = !shapeEditorState[row][col];

            // Update visual
            const grid = document.getElementById('shapeEditorGrid');
            const cellIndex = row * 8 + col;
            const cell = grid.children[cellIndex];
            cell.classList.toggle('filled', shapeEditorState[row][col]);
        }

        function saveCustomShape() {
            // Get filled cells
            const cells = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (shapeEditorState[r][c]) {
                        cells.push([r, c]);
                    }
                }
            }

            // Validate: need at least 1 cell
            if (cells.length === 0) {
                showToast('Please fill in at least one cell', 'error', 2000);
                return;
            }

            // Validate: must be contiguous
            if (!isContiguous(cells)) {
                showToast('Shape must be contiguous (all cells connected)', 'error', 3000);
                return;
            }

            // Get name
            let name = document.getElementById('customShapeName').value.trim();
            if (!name) {
                name = `Custom ${cells.length}-Block`;
            }

            // Normalize cells to start from (0,0)
            const minRow = Math.min(...cells.map(([r, c]) => r));
            const minCol = Math.min(...cells.map(([r, c]) => c));
            const normalizedCells = cells.map(([r, c]) => [r - minRow, c - minCol]);

            // Generate unique ID
            const id = `custom-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;

            // Load existing custom shapes
            let customShapes = {};
            try {
                customShapes = JSON.parse(localStorage.getItem('customShapes') || '{}');
            } catch (e) {}

            // Check for duplicates (same shape already exists)
            for (const [existingId, existing] of Object.entries(customShapes)) {
                if (shapesEqual(existing.cells, normalizedCells)) {
                    showToast(`This shape already exists as "${existing.name}"`, 'error', 3000);
                    return;
                }
            }

            // Also check against built-in shapes
            for (const [builtInId, builtIn] of Object.entries(SHAPE_DEFINITIONS)) {
                if (shapesEqual(builtIn.cells, normalizedCells)) {
                    showToast(`This shape already exists as "${builtIn.name}" (built-in)`, 'error', 3000);
                    return;
                }
            }

            // Save to localStorage
            customShapes[id] = {
                name: name,
                cells: normalizedCells
            };
            localStorage.setItem('customShapes', JSON.stringify(customShapes));

            // Refresh the shape library
            refreshShapeLibrary();

            // Clear editor
            shapeEditorState = Array(8).fill(null).map(() => Array(8).fill(false));
            const grid = document.getElementById('shapeEditorGrid');
            Array.from(grid.children).forEach(cell => cell.classList.remove('filled'));
            document.getElementById('customShapeName').value = '';

            // Refresh list
            renderCustomShapesList();

            // Refresh the solver's shape selector if it exists
            if (typeof renderShapeSelector === 'function') {
                renderShapeSelector();
            }

            showToast(`Shape "${name}" saved!`, 'success', 2000);
        }

        function isContiguous(cells) {
            if (cells.length <= 1) return true;

            const cellSet = new Set(cells.map(([r, c]) => `${r},${c}`));
            const visited = new Set();
            const queue = [cells[0]];
            visited.add(`${cells[0][0]},${cells[0][1]}`);

            while (queue.length > 0) {
                const [r, c] = queue.shift();

                // Check 4-directional neighbors
                const neighbors = [[r-1, c], [r+1, c], [r, c-1], [r, c+1]];
                for (const [nr, nc] of neighbors) {
                    const key = `${nr},${nc}`;
                    if (cellSet.has(key) && !visited.has(key)) {
                        visited.add(key);
                        queue.push([nr, nc]);
                    }
                }
            }

            return visited.size === cells.length;
        }

        function renderCustomShapesList() {
            const container = document.getElementById('customShapesContainer');
            let customShapes = {};
            try {
                customShapes = JSON.parse(localStorage.getItem('customShapes') || '{}');
            } catch (e) {}

            if (Object.keys(customShapes).length === 0) {
                container.innerHTML = '<p class="no-custom-shapes">No custom shapes saved yet.</p>';
                return;
            }

            container.innerHTML = '';

            for (const [id, shape] of Object.entries(customShapes)) {
                const item = document.createElement('div');
                item.className = 'custom-shape-item';

                // Calculate bounds for preview
                const cells = shape.cells;
                const maxRow = Math.max(...cells.map(([r, c]) => r)) + 1;
                const maxCol = Math.max(...cells.map(([r, c]) => c)) + 1;
                const cellSet = new Set(cells.map(([r, c]) => `${r},${c}`));

                // Build preview grid
                const preview = document.createElement('div');
                preview.className = 'custom-shape-preview';
                preview.style.gridTemplateColumns = `repeat(${maxCol}, 8px)`;

                for (let r = 0; r < maxRow; r++) {
                    for (let c = 0; c < maxCol; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell' + (cellSet.has(`${r},${c}`) ? ' filled' : '');
                        preview.appendChild(cell);
                    }
                }

                item.innerHTML = `
                    <div class="shape-info">
                        <div class="preview-container"></div>
                        <div>
                            <div class="custom-shape-name">${shape.name}</div>
                            <div class="custom-shape-cells">${cells.length} cells</div>
                        </div>
                    </div>
                    <button class="btn-delete-shape" onclick="deleteCustomShape('${id}')">Delete</button>
                `;
                item.querySelector('.preview-container').appendChild(preview);

                container.appendChild(item);
            }
        }

        function deleteCustomShape(id) {
            let customShapes = {};
            try {
                customShapes = JSON.parse(localStorage.getItem('customShapes') || '{}');
            } catch (e) {}

            const shapeName = customShapes[id]?.name || 'Shape';
            delete customShapes[id];

            localStorage.setItem('customShapes', JSON.stringify(customShapes));

            // Refresh the shape library
            refreshShapeLibrary();

            // Refresh list
            renderCustomShapesList();

            // Refresh the solver's shape selector if it exists
            if (typeof renderShapeSelector === 'function') {
                renderShapeSelector();
            }

            showToast(`Deleted "${shapeName}"`, 'info', 2000);
        }

        function toggleCustomMode() {
            const customToggle = document.getElementById('customModeToggle');
            const customPanel = document.getElementById('customSettingsPanel');
            puzzleConfig.useCustom = customToggle.checked;

            if (puzzleConfig.useCustom) {
                customPanel.classList.remove('hidden');
                // Clear active difficulty button when using custom
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
            } else {
                customPanel.classList.add('hidden');
                // Re-activate the current difficulty button
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.difficulty === puzzleConfig.difficulty);
                });
            }
        }

        function setDifficulty(difficulty) {
            puzzleConfig.difficulty = difficulty;

            // If custom mode is on, turn it off when selecting a preset difficulty
            if (puzzleConfig.useCustom) {
                puzzleConfig.useCustom = false;
                document.getElementById('customModeToggle').checked = false;
                document.getElementById('customSettingsPanel').classList.add('hidden');
            }

            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.difficulty === difficulty);
            });

            // Note: We no longer update the custom settings panel when selecting a difficulty
            // The pool system will pick a random config when generating
        }

        function togglePuzzleColor(color) {
            const toggle = document.querySelector(`.color-toggle.${color}`);
            const isActive = toggle.classList.toggle('active');

            if (isActive) {
                if (!puzzleConfig.colors.includes(color)) {
                    puzzleConfig.colors.push(color);
                }
            } else {
                puzzleConfig.colors = puzzleConfig.colors.filter(c => c !== color);
            }

            // Ensure at least one color is selected
            if (puzzleConfig.colors.length === 0) {
                puzzleConfig.colors = ['green'];
                document.querySelector('.color-toggle.green').classList.add('active');
                document.querySelector('.color-toggle.green input').checked = true;
            }
        }

        function generatePuzzle() {
            let genConfig;

            if (puzzleConfig.useCustom) {
                // Use custom settings from the UI
                genConfig = {
                    gridRows: parseInt(document.getElementById('puzzleRows').value) || 5,
                    gridCols: parseInt(document.getElementById('puzzleCols').value) || 5,
                    colors: [...puzzleConfig.colors],
                    blockers: document.getElementById('enableBlockers').checked,
                    locks: document.getElementById('enableLocks').checked
                };
            } else {
                // Use pool-based selection
                const pool = DIFFICULTY_POOLS[puzzleConfig.difficulty];
                if (!pool || pool.length === 0) {
                    showToast('No configurations available for this difficulty', 'error', 3000);
                    return;
                }
                // Pick a random config from the pool
                const randomConfig = pool[Math.floor(Math.random() * pool.length)];
                genConfig = {
                    gridRows: randomConfig.gridRows,
                    gridCols: randomConfig.gridCols,
                    colors: [...randomConfig.colors],
                    blockers: randomConfig.blockers,
                    locks: randomConfig.locks
                };
            }

            // Store the active config for the puzzle
            puzzleConfig.gridRows = genConfig.gridRows;
            puzzleConfig.gridCols = genConfig.gridCols;
            puzzleConfig.colors = genConfig.colors;
            puzzleConfig.blockers = genConfig.blockers;
            puzzleConfig.locks = genConfig.locks;

            // Get button and show loading state
            const btn = document.getElementById('generatePuzzleBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Generating...';
            btn.disabled = true;

            console.log('Generating puzzle with config:', genConfig);

            // Use setTimeout to allow UI to update before blocking generation
            setTimeout(() => {
                const puzzle = PuzzleGenerator.generate({
                    gridRows: genConfig.gridRows,
                    gridCols: genConfig.gridCols,
                    colors: genConfig.colors,
                    blockers: genConfig.blockers,
                    locks: genConfig.locks
                });

                // Restore button
                btn.textContent = originalText;
                btn.disabled = false;

                if (puzzle) {
                    currentPuzzle = puzzle;
                    renderPuzzlePlayArea(puzzle);
                    showToast('Puzzle generated!', 'success', 2000);
                } else {
                    showToast('Failed to generate puzzle. Try different settings.', 'error', 4000);
                }
            }, 50);
        }

        function renderPuzzlePlayArea(puzzle) {
            const playArea = document.getElementById('puzzlePlayArea');
            playArea.style.display = 'block';
            playArea.innerHTML = '';

            // Create puzzle container
            const container = document.createElement('div');
            container.className = 'puzzle-container';
            container.innerHTML = `
                <div class="puzzle-main">
                    <div class="puzzle-grid-area">
                        <div class="puzzle-col-requirements" id="puzzleColReqs"></div>
                        <div class="puzzle-grid-row">
                            <div class="puzzle-row-requirements" id="puzzleRowReqs"></div>
                            <div class="puzzle-grid" id="puzzleGrid"></div>
                        </div>
                    </div>
                    <div class="puzzle-shape-palette" id="puzzleShapePalette">
                        <h3>Shapes</h3>
                        <div class="palette-shapes" id="paletteShapes"></div>
                    </div>
                </div>
                <div class="puzzle-actions">
                    <button class="btn btn-primary" onclick="resetPuzzle()">Reset</button>
                    <button class="btn btn-primary" onclick="generatePuzzle()">New Puzzle</button>
                    <button class="btn btn-primary" onclick="showOneHint()" title="Show where one piece goes">Hint</button>
                    <button class="btn btn-primary" onclick="showSolution()" title="Show the full solution">Solution</button>
                </div>
            `;
            playArea.appendChild(container);

            // Render components
            renderPuzzleGrid(puzzle);
            renderPuzzleRequirements(puzzle);
            renderPuzzleShapePalette(puzzle);
        }

        function renderPuzzleGrid(puzzle) {
            const grid = document.getElementById('puzzleGrid');
            const cellSize = puzzle.grid.length > 6 ? (puzzle.grid.length > 8 ? 48 : 56) : 68;

            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = `repeat(${puzzle.grid[0].length}, ${cellSize}px)`;
            grid.style.gap = '0';
            grid.innerHTML = '';

            for (let r = 0; r < puzzle.grid.length; r++) {
                for (let c = 0; c < puzzle.grid[0].length; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    const state = puzzle.grid[r][c];

                    // Determine the PLAYABLE state (not the solved state)
                    // The grid contains the solution - we need to show initial puzzle state
                    let playableState = 'empty';

                    // Check if this cell is a blocker
                    const isBlocker = puzzle.blockers && puzzle.blockers.some(
                        ([br, bc]) => br === r && bc === c
                    );

                    // Check if this cell is a lock
                    let lockColor = null;
                    if (puzzle.locks) {
                        for (const [color, positions] of Object.entries(puzzle.locks)) {
                            if (positions.some(([lr, lc]) => lr === r && lc === c)) {
                                lockColor = color;
                                break;
                            }
                        }
                    }

                    if (isBlocker) {
                        cell.classList.add('blocked');
                        playableState = 'blocked';
                    } else if (lockColor) {
                        cell.classList.add(`locked-${lockColor}`);
                        playableState = `locked-${lockColor}`;
                    }

                    // Store states for puzzle
                    cell.dataset.originalState = playableState;
                    cell.dataset.currentState = playableState;

                    // Right-click to remove placed shapes (desktop)
                    cell.addEventListener('contextmenu', handleCellRightClick);

                    // Touch removal handlers (mobile - long-press and double-tap)
                    addRemovalTouchHandlers(cell);

                    grid.appendChild(cell);
                }
            }
        }

        function renderPuzzleRequirements(puzzle) {
            const colReqs = document.getElementById('puzzleColReqs');
            const rowReqs = document.getElementById('puzzleRowReqs');
            const colors = puzzleConfig.colors;

            // Column requirements
            colReqs.innerHTML = '';
            colReqs.style.display = 'flex';
            colReqs.style.gap = '0';
            colReqs.style.marginLeft = '60px'; // Spacer for row reqs

            for (let c = 0; c < puzzle.requirements.cols.length; c++) {
                const colReq = document.createElement('div');
                colReq.className = 'puzzle-col-req';
                colReq.style.width = (puzzle.grid.length > 6 ? (puzzle.grid.length > 8 ? 48 : 56) : 68) + 'px';
                colReq.style.display = 'flex';
                colReq.style.justifyContent = 'center';
                colReq.style.gap = '1px';

                for (const color of colors) {
                    const count = puzzle.requirements.cols[c][color] || 0;
                    if (count > 0) {
                        const bar = createPrescriptiveBar(color, count, 'col', c);
                        colReq.appendChild(bar);
                    }
                }

                colReqs.appendChild(colReq);
            }

            // Row requirements
            rowReqs.innerHTML = '';
            rowReqs.style.display = 'flex';
            rowReqs.style.flexDirection = 'column';
            rowReqs.style.gap = '0';

            for (let r = 0; r < puzzle.requirements.rows.length; r++) {
                const rowReq = document.createElement('div');
                rowReq.className = 'puzzle-row-req';
                rowReq.style.height = (puzzle.grid.length > 6 ? (puzzle.grid.length > 8 ? 48 : 56) : 68) + 'px';
                rowReq.style.display = 'flex';
                rowReq.style.flexDirection = 'column';
                rowReq.style.justifyContent = 'center';
                rowReq.style.gap = '1px';
                rowReq.style.width = '60px';

                for (const color of colors) {
                    const count = puzzle.requirements.rows[r][color] || 0;
                    if (count > 0) {
                        const bar = createPrescriptiveBar(color, count, 'row', r);
                        rowReq.appendChild(bar);
                    }
                }

                rowReqs.appendChild(rowReq);
            }
        }

        function createPrescriptiveBar(color, totalCount, type, index) {
            const container = document.createElement('div');
            container.className = `prescriptive-bar ${color}`;
            container.dataset.color = color;
            container.dataset.type = type;
            container.dataset.index = index;
            container.dataset.required = totalCount;

            // Max segments based on grid size (for consistent sizing)
            const maxSegments = type === 'col' ? currentPuzzle.grid.length : currentPuzzle.grid[0].length;

            // Calculate current fill from locked cells
            let currentFill = 0;
            if (currentPuzzle) {
                if (type === 'col') {
                    for (let r = 0; r < currentPuzzle.grid.length; r++) {
                        const cell = currentPuzzle.grid[r][index];
                        if (cell === `locked-${color}`) currentFill++;
                    }
                } else {
                    for (let c = 0; c < currentPuzzle.grid[0].length; c++) {
                        const cell = currentPuzzle.grid[index][c];
                        if (cell === `locked-${color}`) currentFill++;
                    }
                }
            }

            container.dataset.filled = currentFill;

            // Fixed bar dimensions based on grid max
            const isRow = type === 'row';
            container.style.display = 'flex';
            container.style.flexDirection = isRow ? 'row-reverse' : 'column-reverse';
            container.style.gap = '1px';

            // Fixed size: calculate segment size based on max, then multiply
            const segmentSize = Math.floor((55 - (maxSegments - 1)) / maxSegments);

            if (isRow) {
                container.style.width = '55px';
                container.style.height = '14px';
            } else {
                container.style.width = '14px';
                container.style.height = '55px';
            }

            // Only render the segments we need (totalCount), but size them consistently
            for (let i = 0; i < totalCount; i++) {
                const segment = document.createElement('div');
                segment.className = 'prescriptive-segment';

                if (isRow) {
                    segment.style.width = segmentSize + 'px';
                    segment.style.height = '100%';
                } else {
                    segment.style.width = '100%';
                    segment.style.height = segmentSize + 'px';
                }

                // Set border color based on color
                const colorMap = {
                    green: '#39ff14',
                    blue: '#00bfff',
                    red: '#ff3939',
                    purple: '#bf39ff'
                };
                const borderColor = colorMap[color] || '#39ff14';
                segment.style.border = `2px solid ${borderColor}`;
                segment.style.borderRadius = '1px';

                if (i < currentFill) {
                    segment.classList.add('filled');
                    segment.style.background = borderColor;
                }

                container.appendChild(segment);
            }

            return container;
        }

        function renderPuzzleShapePalette(puzzle) {
            const palette = document.getElementById('paletteShapes');
            palette.innerHTML = '';

            for (const color of puzzleConfig.colors) {
                const shapes = puzzle.shapes[color] || [];

                for (const shape of shapes) {
                    const shapeEl = document.createElement('div');
                    shapeEl.className = `palette-shape ${color}`;
                    shapeEl.dataset.shapeId = shape.shapeId;
                    shapeEl.dataset.color = color;

                    // IMPORTANT: Randomize the initial display rotation, NOT the solution rotation
                    // This forces the user to potentially rotate shapes to solve
                    const shapeData = SHAPE_LIBRARY[shape.shapeId];
                    const randomDisplayRotation = Math.floor(Math.random() * shapeData.rotations.length);
                    shapeEl.dataset.rotationIndex = randomDisplayRotation;

                    // Store solution data for hints (solution rotation + position)
                    shapeEl.dataset.solutionRotationIndex = shape.rotationIndex;
                    shapeEl.dataset.solutionRow = shape.position[0];
                    shapeEl.dataset.solutionCol = shape.position[1];
                    shapeEl.style.cursor = 'grab';

                    // Render shape preview using the randomized display rotation
                    const rotation = shapeData.rotations[randomDisplayRotation];
                    const bounds = getShapeBounds(rotation);

                    const preview = document.createElement('div');
                    preview.className = 'shape-preview-grid';
                    preview.style.display = 'grid';
                    preview.style.gridTemplateColumns = `repeat(${bounds.width}, 12px)`;
                    preview.style.gap = '1px';

                    const cellSet = new Set(rotation.map(([r, c]) => `${r},${c}`));

                    for (let r = 0; r < bounds.height; r++) {
                        for (let c = 0; c < bounds.width; c++) {
                            const cell = document.createElement('div');
                            cell.style.width = '12px';
                            cell.style.height = '12px';
                            cell.style.borderRadius = '1px';

                            if (cellSet.has(`${r},${c}`)) {
                                cell.style.background = color === 'green' ? '#39ff14' :
                                                        color === 'blue' ? '#00bfff' :
                                                        color === 'red' ? '#ff3939' : '#bf39ff';
                            } else {
                                cell.style.background = '#1a1a1a';
                            }

                            preview.appendChild(cell);
                        }
                    }

                    shapeEl.appendChild(preview);
                    palette.appendChild(shapeEl);

                    // Add drag handlers
                    shapeEl.addEventListener('mousedown', handleShapeMouseDown);

                    // Add touch handler for mobile support
                    addTouchHandlerToShape(shapeEl);
                }
            }
        }

        // Custom drag system state
        let dragState = {
            active: false,
            shapeId: null,
            color: null,
            rotationIndex: 0,
            sourceElement: null,
            ghost: null,
            gridCellSize: 68,
            lastGridCell: null
        };

        function handleShapeMouseDown(e) {
            const shapeEl = e.target.closest('.palette-shape');
            if (!shapeEl || e.button !== 0) return;

            e.preventDefault();

            const shapeId = shapeEl.dataset.shapeId;
            const color = shapeEl.dataset.color;
            const rotationIndex = parseInt(shapeEl.dataset.rotationIndex);

            // Get grid cell size
            const cellSize = currentPuzzle.grid.length > 6 ?
                (currentPuzzle.grid.length > 8 ? 48 : 56) : 68;

            dragState = {
                active: true,
                shapeId,
                color,
                rotationIndex,
                sourceElement: shapeEl,
                ghost: null,
                gridCellSize: cellSize,
                lastGridCell: null
            };

            // Create ghost element
            createDragGhost(e.clientX, e.clientY);

            // Hide source element
            shapeEl.style.opacity = '0.3';

            // Add document-level listeners
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('keydown', handleDragKeyDown);
        }

        function createDragGhost(x, y) {
            if (dragState.ghost) {
                dragState.ghost.remove();
            }

            const shapeData = SHAPE_LIBRARY[dragState.shapeId];
            const rotation = shapeData.rotations[dragState.rotationIndex];
            const bounds = getShapeBounds(rotation);
            const cellSize = dragState.gridCellSize;

            const ghost = document.createElement('div');
            ghost.id = 'drag-ghost';
            ghost.style.cssText = `
                position: fixed;
                pointer-events: none;
                z-index: 10000;
                opacity: 0.8;
                display: grid;
                grid-template-columns: repeat(${bounds.width}, ${cellSize}px);
                grid-template-rows: repeat(${bounds.height}, ${cellSize}px);
                gap: 0;
            `;

            // Build cell set for border checking
            const cellSet = new Set(rotation.map(([r, c]) => `${r},${c}`));

            // Create cells for the shape
            let cellIndex = 0;
            for (let r = 0; r < bounds.height; r++) {
                for (let c = 0; c < bounds.width; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';

                    // Check if this cell is part of the shape
                    const isShapeCell = rotation.some(([sr, sc]) => sr === r && sc === c);

                    if (isShapeCell) {
                        cell.className = `cell ${dragState.color}`;
                        cell.style.boxSizing = 'border-box';

                        // Alternating shade based on checkerboard pattern (relative to shape bounds)
                        if ((r + c) % 2 === 1) {
                            cell.classList.add('shade-alt');
                        }

                        // Check neighbors for border edges
                        const topKey = `${r - 1},${c}`;
                        const rightKey = `${r},${c + 1}`;
                        const bottomKey = `${r + 1},${c}`;
                        const leftKey = `${r},${c - 1}`;
                        
                        // Check diagonals for Inner Corners
                        const tlKey = `${r - 1},${c - 1}`;
                        const trKey = `${r - 1},${c + 1}`;
                        const brKey = `${r + 1},${c + 1}`;
                        const blKey = `${r + 1},${c - 1}`;

                        const hasTop = !cellSet.has(topKey);
                        const hasRight = !cellSet.has(rightKey);
                        const hasBottom = !cellSet.has(bottomKey);
                        const hasLeft = !cellSet.has(leftKey);

                        // Apply Borders
                        if (hasTop) cell.classList.add('border-top');
                        if (hasRight) cell.classList.add('border-right');
                        if (hasBottom) cell.classList.add('border-bottom');
                        if (hasLeft) cell.classList.add('border-left');
                        
                        // Apply Inner Corners (If neighbors exist but diagonal is empty)
                        if (!hasTop && !hasLeft && !cellSet.has(tlKey)) cell.classList.add('corner-tl');
                        if (!hasTop && !hasRight && !cellSet.has(trKey)) cell.classList.add('corner-tr');
                        if (!hasBottom && !hasRight && !cellSet.has(brKey)) cell.classList.add('corner-br');
                        if (!hasBottom && !hasLeft && !cellSet.has(blKey)) cell.classList.add('corner-bl');
                    } else {
                        cell.style.background = 'transparent';
                    }

                    ghost.appendChild(cell);
                }
            }

            // Position centered on cursor
            const ghostWidth = bounds.width * cellSize;
            const ghostHeight = bounds.height * cellSize;
            ghost.style.left = (x - ghostWidth / 2) + 'px';
            ghost.style.top = (y - ghostHeight / 2) + 'px';

            document.body.appendChild(ghost);
            dragState.ghost = ghost;
        }

        function handleDragMove(e) {
            if (!dragState.active || !dragState.ghost) return;

            const shapeData = SHAPE_LIBRARY[dragState.shapeId];
            const rotation = shapeData.rotations[dragState.rotationIndex];
            const bounds = getShapeBounds(rotation);
            const cellSize = dragState.gridCellSize;

            const ghostWidth = bounds.width * cellSize;
            const ghostHeight = bounds.height * cellSize;

            // Update ghost position
            dragState.ghost.style.left = (e.clientX - ghostWidth / 2) + 'px';
            dragState.ghost.style.top = (e.clientY - ghostHeight / 2) + 'px';

            // Check if over puzzle grid and highlight cells
            const puzzleGrid = document.getElementById('puzzleGrid');
            if (!puzzleGrid) return;

            const gridRect = puzzleGrid.getBoundingClientRect();
            const gridX = e.clientX - gridRect.left;
            const gridY = e.clientY - gridRect.top;

            // Clear previous highlights
            clearGridHighlights();

            // Check if cursor is within grid bounds
            if (gridX >= 0 && gridX < gridRect.width && gridY >= 0 && gridY < gridRect.height) {
                // Calculate grid cell under cursor
                const col = Math.floor(gridX / cellSize);
                const row = Math.floor(gridY / cellSize);

                // Adjust to place shape centered/offset from cursor
                const startRow = row - Math.floor(bounds.height / 2);
                const startCol = col - Math.floor(bounds.width / 2);

                dragState.lastGridCell = { row: startRow, col: startCol };

                // Check validity and highlight cells
                const validity = checkPlacementValidity(startRow, startCol, rotation);
                highlightPlacementCells(startRow, startCol, rotation, validity);
            } else {
                dragState.lastGridCell = null;
            }
        }

        function handleDragKeyDown(e) {
            if (!dragState.active) return;

            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();

                // Rotate to next rotation
                const shapeData = SHAPE_LIBRARY[dragState.shapeId];
                dragState.rotationIndex = (dragState.rotationIndex + 1) % shapeData.rotations.length;

                // Recreate ghost with new rotation
                const ghost = dragState.ghost;
                if (ghost) {
                    const rect = ghost.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    createDragGhost(centerX, centerY);
                }

                // Update grid highlights
                if (dragState.lastGridCell) {
                    clearGridHighlights();
                    const shapeData = SHAPE_LIBRARY[dragState.shapeId];
                    const rotation = shapeData.rotations[dragState.rotationIndex];
                    const validity = checkPlacementValidity(
                        dragState.lastGridCell.row,
                        dragState.lastGridCell.col,
                        rotation
                    );
                    highlightPlacementCells(
                        dragState.lastGridCell.row,
                        dragState.lastGridCell.col,
                        rotation,
                        validity
                    );
                }
            }
        }

        function handleDragEnd(e) {
            if (!dragState.active) return;

            // Remove listeners
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('keydown', handleDragKeyDown);

            // Try to place shape
            let placed = false;
            if (dragState.lastGridCell) {
                const shapeData = SHAPE_LIBRARY[dragState.shapeId];
                const rotation = shapeData.rotations[dragState.rotationIndex];
                const validity = checkPlacementValidity(
                    dragState.lastGridCell.row,
                    dragState.lastGridCell.col,
                    rotation
                );

                if (validity.valid) {
                    // Remove shape from palette BEFORE placing (so win check sees empty palette)
                    if (dragState.sourceElement) {
                        dragState.sourceElement.remove();
                    }

                    placeShapeOnGrid(
                        dragState.lastGridCell.row,
                        dragState.lastGridCell.col,
                        rotation,
                        dragState.color,
                        dragState.shapeId,
                        dragState.rotationIndex
                    );
                    placed = true;
                }
            }

            // Restore source element if not placed
            if (!placed && dragState.sourceElement) {
                dragState.sourceElement.style.opacity = '1';
            }

            // Clean up
            clearGridHighlights();
            if (dragState.ghost) {
                dragState.ghost.remove();
            }

            dragState = {
                active: false,
                shapeId: null,
                color: null,
                rotationIndex: 0,
                sourceElement: null,
                ghost: null,
                gridCellSize: 68,
                lastGridCell: null
            };
        }

        // ============================================
        // MOBILE SUPPORT - Touch Drag System
        // ============================================

        // Touch drag state machine: 'idle' -> 'dragging' -> 'awaiting-action' -> 'idle'
        let touchDragState = {
            phase: 'idle', // 'idle', 'dragging', 'awaiting-action'
            shapeId: null,
            color: null,
            rotationIndex: 0,
            sourceElement: null,
            ghost: null,
            gridCellSize: 68,
            lastGridCell: null,
            lastTouchPos: { x: 0, y: 0 },
            solutionData: null // For hints to work
        };

        // Called when mobile mode is toggled ON
        function initMobileInteractions() {
            console.log('Mobile mode enabled - touch interactions ready');
            // Global handlers are already set up via initGlobalTouchHandlers
            // Touch handlers on shapes are added when shapes are created
        }

        // Cleanup touch handlers when mobile mode is disabled
        function cleanupMobileInteractions() {
            console.log('Cleaning up mobile touch interactions');

            const paletteShapes = document.querySelectorAll('#paletteShapes .palette-shape');
            paletteShapes.forEach(shape => {
                shape.removeEventListener('touchstart', handleShapeTouchStart);
            });

            document.removeEventListener('touchmove', handleTouchDragMove);
            document.removeEventListener('touchend', handleTouchDragEnd);

            // Clean up any active touch drag
            cancelTouchDrag();
        }

        function handleShapeTouchStart(e) {
            // Handle touch events when:
            // 1. Mobile mode is forced (for testing)
            // 2. Device has touch capability (auto-detected)
            // 3. Device has coarse pointer (touch primary input)
            if (!mobileMode && !DeviceCapabilities.hasTouch) return;

            const shapeEl = e.target.closest('.palette-shape');
            if (!shapeEl) return;

            e.preventDefault();

            const touch = e.touches[0];
            const shapeId = shapeEl.dataset.shapeId;
            const color = shapeEl.dataset.color;
            const rotationIndex = parseInt(shapeEl.dataset.rotationIndex);

            // Get grid cell size
            const cellSize = currentPuzzle ? (currentPuzzle.grid.length > 6 ?
                (currentPuzzle.grid.length > 8 ? 48 : 56) : 68) : 68;

            // Store solution data for hints
            const solutionData = {
                solutionRotationIndex: shapeEl.dataset.solutionRotationIndex,
                solutionRow: shapeEl.dataset.solutionRow,
                solutionCol: shapeEl.dataset.solutionCol
            };

            touchDragState = {
                phase: 'dragging',
                shapeId,
                color,
                rotationIndex,
                sourceElement: shapeEl,
                ghost: null,
                gridCellSize: cellSize,
                lastGridCell: null,
                lastTouchPos: { x: touch.clientX, y: touch.clientY },
                solutionData
            };

            // Prevent scrolling during drag
            document.body.classList.add('touch-dragging');

            // Create ghost element (offset above finger)
            createTouchDragGhost(touch.clientX, touch.clientY);

            // Hide source element
            shapeEl.style.opacity = '0.3';

            console.log('Touch drag started:', shapeId, color);
        }

        function createTouchDragGhost(x, y) {
            if (touchDragState.ghost) {
                touchDragState.ghost.remove();
            }

            const shapeData = SHAPE_LIBRARY[touchDragState.shapeId];
            const rotation = shapeData.rotations[touchDragState.rotationIndex];
            const bounds = getShapeBounds(rotation);
            const cellSize = touchDragState.gridCellSize;

            const ghost = document.createElement('div');
            ghost.id = 'touch-drag-ghost';
            ghost.className = 'touch-floating-shape';

            const ghostWidth = bounds.width * cellSize;
            const ghostHeight = bounds.height * cellSize;

            ghost.style.cssText = `
                position: fixed;
                z-index: 10000;
                opacity: 0.9;
                display: grid;
                grid-template-columns: repeat(${bounds.width}, ${cellSize}px);
                grid-template-rows: repeat(${bounds.height}, ${cellSize}px);
                gap: 0;
                left: ${x - ghostWidth / 2}px;
                top: ${y - ghostHeight / 2 - 60}px;
            `;

            // Build cell set for border checking
            const cellSet = new Set(rotation.map(([r, c]) => `${r},${c}`));

            // Create cells for the shape
            for (let r = 0; r < bounds.height; r++) {
                for (let c = 0; c < bounds.width; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';

                    const isShapeCell = rotation.some(([sr, sc]) => sr === r && sc === c);

                    if (isShapeCell) {
                        cell.className = `cell ${touchDragState.color}`;
                        cell.style.boxSizing = 'border-box';

                        if ((r + c) % 2 === 1) {
                            cell.classList.add('shade-alt');
                        }

                        // Check neighbors for border edges
                        const hasTop = !cellSet.has(`${r - 1},${c}`);
                        const hasRight = !cellSet.has(`${r},${c + 1}`);
                        const hasBottom = !cellSet.has(`${r + 1},${c}`);
                        const hasLeft = !cellSet.has(`${r},${c - 1}`);

                        if (hasTop) cell.classList.add('border-top');
                        if (hasRight) cell.classList.add('border-right');
                        if (hasBottom) cell.classList.add('border-bottom');
                        if (hasLeft) cell.classList.add('border-left');

                        // Inner corners
                        if (!hasTop && !hasLeft && !cellSet.has(`${r - 1},${c - 1}`)) cell.classList.add('corner-tl');
                        if (!hasTop && !hasRight && !cellSet.has(`${r - 1},${c + 1}`)) cell.classList.add('corner-tr');
                        if (!hasBottom && !hasRight && !cellSet.has(`${r + 1},${c + 1}`)) cell.classList.add('corner-br');
                        if (!hasBottom && !hasLeft && !cellSet.has(`${r + 1},${c - 1}`)) cell.classList.add('corner-bl');
                    } else {
                        cell.style.background = 'transparent';
                    }

                    ghost.appendChild(cell);
                }
            }

            document.body.appendChild(ghost);
            touchDragState.ghost = ghost;
        }

        function handleTouchDragMove(e) {
            if (touchDragState.phase !== 'dragging') return;
            if (!touchDragState.ghost) return;

            // Prevent scrolling while dragging
            e.preventDefault();
            e.stopPropagation();

            const touch = e.touches[0];
            touchDragState.lastTouchPos = { x: touch.clientX, y: touch.clientY };

            const shapeData = SHAPE_LIBRARY[touchDragState.shapeId];
            const rotation = shapeData.rotations[touchDragState.rotationIndex];
            const bounds = getShapeBounds(rotation);
            const cellSize = touchDragState.gridCellSize;

            const ghostWidth = bounds.width * cellSize;
            const ghostHeight = bounds.height * cellSize;

            // Update ghost position (offset above finger)
            touchDragState.ghost.style.left = (touch.clientX - ghostWidth / 2) + 'px';
            touchDragState.ghost.style.top = (touch.clientY - ghostHeight / 2 - 60) + 'px';

            // Check if over puzzle grid and highlight cells
            const puzzleGrid = document.getElementById('puzzleGrid');
            if (!puzzleGrid) return;

            const gridRect = puzzleGrid.getBoundingClientRect();
            const gridX = touch.clientX - gridRect.left;
            const gridY = touch.clientY - gridRect.top;

            clearGridHighlights();

            if (gridX >= 0 && gridX < gridRect.width && gridY >= 0 && gridY < gridRect.height) {
                const col = Math.floor(gridX / cellSize);
                const row = Math.floor(gridY / cellSize);

                const startRow = row - Math.floor(bounds.height / 2);
                const startCol = col - Math.floor(bounds.width / 2);

                touchDragState.lastGridCell = { row: startRow, col: startCol };

                const validity = checkPlacementValidity(startRow, startCol, rotation);
                highlightPlacementCells(startRow, startCol, rotation, validity);
            } else {
                touchDragState.lastGridCell = null;
            }
        }

        function handleTouchDragEnd(e) {
            if (touchDragState.phase !== 'dragging') return;

            // Don't prevent default here - we want to allow other touch interactions

            // Transition to awaiting-action phase
            touchDragState.phase = 'awaiting-action';

            // Make ghost interactive
            if (touchDragState.ghost) {
                touchDragState.ghost.classList.add('awaiting-action');
            }

            // Show rotate button near the ghost
            showMobileRotateButton();

            // Set up listener for placement/dismissal
            setTimeout(() => {
                document.addEventListener('touchstart', handleAwaitingActionTap, { passive: false });
            }, 100);

            console.log('Touch drag ended, awaiting action');
        }

        function handleAwaitingActionTap(e) {
            if (touchDragState.phase !== 'awaiting-action') {
                document.removeEventListener('touchstart', handleAwaitingActionTap);
                return;
            }

            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);

            // Check if tapped on rotate button
            if (target && target.closest('#mobileRotateBtn')) {
                // Rotate is handled by its own handler
                return;
            }

            // Check if tapped on the floating ghost - resume dragging
            if (target && target.closest('#touch-drag-ghost')) {
                e.preventDefault();
                // Resume dragging from this position
                touchDragState.phase = 'dragging';
                touchDragState.lastTouchPos = { x: touch.clientX, y: touch.clientY };
                if (touchDragState.ghost) {
                    touchDragState.ghost.classList.remove('awaiting-action');
                }
                hideMobileRotateButton();
                document.removeEventListener('touchstart', handleAwaitingActionTap);
                console.log('Resumed dragging from ghost tap');
                return;
            }

            // Check if tapped on grid
            const puzzleGrid = document.getElementById('puzzleGrid');
            if (puzzleGrid && target && (target.closest('#puzzleGrid') || puzzleGrid.contains(target))) {
                e.preventDefault();

                // Try to place at the last known valid position
                const shapeData = SHAPE_LIBRARY[touchDragState.shapeId];
                const rotation = shapeData.rotations[touchDragState.rotationIndex];

                // Calculate placement position from tap
                const gridRect = puzzleGrid.getBoundingClientRect();
                const gridX = touch.clientX - gridRect.left;
                const gridY = touch.clientY - gridRect.top;
                const cellSize = touchDragState.gridCellSize;

                const col = Math.floor(gridX / cellSize);
                const row = Math.floor(gridY / cellSize);
                const bounds = getShapeBounds(rotation);
                const startRow = row - Math.floor(bounds.height / 2);
                const startCol = col - Math.floor(bounds.width / 2);

                const validity = checkPlacementValidity(startRow, startCol, rotation);

                if (validity.valid) {
                    // Remove from palette BEFORE placing (so win check sees empty palette)
                    if (touchDragState.sourceElement) {
                        touchDragState.sourceElement.remove();
                    }

                    // Place the shape (this internally calls updatePuzzleBars and checkWinCondition)
                    placeShapeOnGrid(
                        startRow,
                        startCol,
                        rotation,
                        touchDragState.color,
                        touchDragState.shapeId,
                        touchDragState.rotationIndex
                    );

                    // Clean up
                    finishTouchDrag(true);
                } else {
                    // Invalid placement - show feedback
                    showToast('Invalid placement', 'error', 1500);
                }

                return;
            }

            // Tapped elsewhere - dismiss/cancel
            e.preventDefault();
            cancelTouchDrag();
        }

        function handleMobileRotate() {
            if (touchDragState.phase !== 'awaiting-action' && touchDragState.phase !== 'dragging') return;

            const shapeData = SHAPE_LIBRARY[touchDragState.shapeId];
            touchDragState.rotationIndex = (touchDragState.rotationIndex + 1) % shapeData.rotations.length;

            // Recreate ghost with new rotation
            if (touchDragState.ghost) {
                const rect = touchDragState.ghost.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2 + 60; // Account for offset
                createTouchDragGhost(centerX, centerY);

                if (touchDragState.phase === 'awaiting-action') {
                    touchDragState.ghost.classList.add('awaiting-action');
                }
            }

            // Update highlights if over grid
            if (touchDragState.lastGridCell) {
                clearGridHighlights();
                const rotation = shapeData.rotations[touchDragState.rotationIndex];
                const validity = checkPlacementValidity(
                    touchDragState.lastGridCell.row,
                    touchDragState.lastGridCell.col,
                    rotation
                );
                highlightPlacementCells(
                    touchDragState.lastGridCell.row,
                    touchDragState.lastGridCell.col,
                    rotation,
                    validity
                );
            }

            // Reposition rotate button
            showMobileRotateButton();

            console.log('Shape rotated to index:', touchDragState.rotationIndex);
        }

        function showMobileRotateButton() {
            const rotateBtn = document.getElementById('mobileRotateBtn');
            if (!rotateBtn || !touchDragState.ghost) return;

            const ghostRect = touchDragState.ghost.getBoundingClientRect();

            // Position to the right of the ghost
            rotateBtn.style.left = (ghostRect.right + 10) + 'px';
            rotateBtn.style.top = (ghostRect.top + ghostRect.height / 2 - 28) + 'px';
            rotateBtn.classList.add('visible');
        }

        function hideMobileRotateButton() {
            const rotateBtn = document.getElementById('mobileRotateBtn');
            if (rotateBtn) {
                rotateBtn.classList.remove('visible');
            }
        }

        function finishTouchDrag(placed) {
            document.removeEventListener('touchstart', handleAwaitingActionTap);

            // Re-enable scrolling
            document.body.classList.remove('touch-dragging');

            clearGridHighlights();
            hideMobileRotateButton();

            if (touchDragState.ghost) {
                touchDragState.ghost.remove();
            }

            touchDragState = {
                phase: 'idle',
                shapeId: null,
                color: null,
                rotationIndex: 0,
                sourceElement: null,
                ghost: null,
                gridCellSize: 68,
                lastGridCell: null,
                lastTouchPos: { x: 0, y: 0 },
                solutionData: null
            };
        }

        function cancelTouchDrag() {
            // Restore source element
            if (touchDragState.sourceElement) {
                touchDragState.sourceElement.style.opacity = '1';
            }

            finishTouchDrag(false);
            console.log('Touch drag cancelled');
        }

        // Add touch handler to newly created palette shapes
        // Always add the handler - it checks mode at runtime
        function addTouchHandlerToShape(shapeEl) {
            shapeEl.addEventListener('touchstart', handleShapeTouchStart, { passive: false });
        }

        function checkPlacementValidity(startRow, startCol, rotation) {
            const result = { valid: true, cells: [] };

            for (const [dr, dc] of rotation) {
                const r = startRow + dr;
                const c = startCol + dc;

                const cellInfo = { row: r, col: c, valid: true };

                // Check bounds
                if (r < 0 || r >= currentPuzzle.grid.length ||
                    c < 0 || c >= currentPuzzle.grid[0].length) {
                    cellInfo.valid = false;
                    result.valid = false;
                } else {
                    // Check cell state
                    const gridCell = document.querySelector(
                        `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                    );
                    if (gridCell) {
                        const state = gridCell.dataset.currentState;
                        if (state !== 'empty') {
                            cellInfo.valid = false;
                            result.valid = false;
                        }
                    }
                }

                result.cells.push(cellInfo);
            }

            return result;
        }

        function highlightPlacementCells(startRow, startCol, rotation, validity) {
            for (const cellInfo of validity.cells) {
                if (cellInfo.row < 0 || cellInfo.row >= currentPuzzle.grid.length ||
                    cellInfo.col < 0 || cellInfo.col >= currentPuzzle.grid[0].length) {
                    continue;
                }

                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${cellInfo.row}"][data-col="${cellInfo.col}"]`
                );
                if (gridCell) {
                    if (validity.valid) {
                        gridCell.classList.add('placement-valid');
                    } else {
                        gridCell.classList.add('placement-invalid');
                    }
                }
            }
        }

        function clearGridHighlights() {
            document.querySelectorAll('#puzzleGrid .cell').forEach(cell => {
                cell.classList.remove('placement-valid', 'placement-invalid');
            });
        }

        function placeShapeOnGrid(startRow, startCol, rotation, color, shapeId, rotationIndex) {
            // Build a set of all cells in this shape for neighbor checking
            const cellSet = new Set(rotation.map(([dr, dc]) => `${startRow + dr},${startCol + dc}`));

            rotation.forEach(([dr, dc], cellIndex) => {
                const r = startRow + dr;
                const c = startCol + dc;

                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                );
                if (gridCell) {
                    gridCell.classList.add(color);
                    gridCell.classList.add('placed');
                    gridCell.dataset.currentState = color;
                    gridCell.dataset.placedShapeId = shapeId;
                    gridCell.dataset.placedRotation = rotationIndex;

                    // Alternating shade based on checkerboard pattern (row + col parity)
                    if ((r + c) % 2 === 1) {
                        gridCell.classList.add('shade-alt');
                    }

                    // Check neighbors for border edges
                    const topKey = `${r - 1},${c}`;
                    const rightKey = `${r},${c + 1}`;
                    const bottomKey = `${r + 1},${c}`;
                    const leftKey = `${r},${c - 1}`;

                    // Check diagonals for Inner Corners
                    const tlKey = `${r - 1},${c - 1}`;
                    const trKey = `${r - 1},${c + 1}`;
                    const brKey = `${r + 1},${c + 1}`;
                    const blKey = `${r + 1},${c - 1}`;

                    const hasTop = !cellSet.has(topKey);
                    const hasRight = !cellSet.has(rightKey);
                    const hasBottom = !cellSet.has(bottomKey);
                    const hasLeft = !cellSet.has(leftKey);

                    // Apply Borders
                    if (hasTop) gridCell.classList.add('border-top');
                    if (hasRight) gridCell.classList.add('border-right');
                    if (hasBottom) gridCell.classList.add('border-bottom');
                    if (hasLeft) gridCell.classList.add('border-left');

                    // Apply Inner Corners
                    if (!hasTop && !hasLeft && !cellSet.has(tlKey)) gridCell.classList.add('corner-tl');
                    if (!hasTop && !hasRight && !cellSet.has(trKey)) gridCell.classList.add('corner-tr');
                    if (!hasBottom && !hasRight && !cellSet.has(brKey)) gridCell.classList.add('corner-br');
                    if (!hasBottom && !hasLeft && !cellSet.has(blKey)) gridCell.classList.add('corner-bl');
                }
            });

            // Update requirements bars
            updatePuzzleBars();

            // Check win condition
            checkWinCondition();
        }

        function updatePuzzleBars() {
            if (!currentPuzzle) return;

            const colors = puzzleConfig.colors;
            const grid = currentPuzzle.grid;
            const rows = grid.length;
            const cols = grid[0].length;

            // Count current fills per row/col/color
            for (let r = 0; r < rows; r++) {
                for (const color of colors) {
                    let count = 0;
                    for (let c = 0; c < cols; c++) {
                        const cell = document.querySelector(
                            `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                        );
                        if (cell && (cell.dataset.currentState === color ||
                            cell.dataset.currentState === `locked-${color}`)) {
                            count++;
                        }
                    }

                    // Update row bar
                    const bar = document.querySelector(
                        `.prescriptive-bar[data-type="row"][data-index="${r}"][data-color="${color}"]`
                    );
                    if (bar) {
                        const required = parseInt(bar.dataset.required);
                        const segments = bar.querySelectorAll('.prescriptive-segment');
                        const colorMap = {
                            green: '#39ff14',
                            blue: '#00bfff',
                            red: '#ff3939',
                            purple: '#bf39ff'
                        };

                        segments.forEach((seg, i) => {
                            if (i < count) {
                                seg.classList.add('filled');
                                seg.style.background = colorMap[color];
                            } else {
                                seg.classList.remove('filled');
                                seg.style.background = 'transparent';
                            }
                        });

                        // Error state if exceeded
                        if (count > required) {
                            bar.classList.add('error');
                        } else {
                            bar.classList.remove('error');
                        }
                    }
                }
            }

            for (let c = 0; c < cols; c++) {
                for (const color of colors) {
                    let count = 0;
                    for (let r = 0; r < rows; r++) {
                        const cell = document.querySelector(
                            `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                        );
                        if (cell && (cell.dataset.currentState === color ||
                            cell.dataset.currentState === `locked-${color}`)) {
                            count++;
                        }
                    }

                    // Update col bar
                    const bar = document.querySelector(
                        `.prescriptive-bar[data-type="col"][data-index="${c}"][data-color="${color}"]`
                    );
                    if (bar) {
                        const required = parseInt(bar.dataset.required);
                        const segments = bar.querySelectorAll('.prescriptive-segment');
                        const colorMap = {
                            green: '#39ff14',
                            blue: '#00bfff',
                            red: '#ff3939',
                            purple: '#bf39ff'
                        };

                        segments.forEach((seg, i) => {
                            if (i < count) {
                                seg.classList.add('filled');
                                seg.style.background = colorMap[color];
                            } else {
                                seg.classList.remove('filled');
                                seg.style.background = 'transparent';
                            }
                        });

                        // Error state if exceeded
                        if (count > required) {
                            bar.classList.add('error');
                        } else {
                            bar.classList.remove('error');
                        }
                    }
                }
            }
        }

        function handleCellRightClick(e) {
            e.preventDefault();
            const cell = e.target.closest('.cell');
            if (!cell || !cell.classList.contains('placed')) return;

            const shapeId = cell.dataset.placedShapeId;
            const rotationIndex = parseInt(cell.dataset.placedRotation);

            // Find color from cell class
            let color = null;
            for (const c of puzzleConfig.colors) {
                if (cell.classList.contains(c)) {
                    color = c;
                    break;
                }
            }
            if (!color) return;

            // Find all cells of this placed shape
            const allPlacedCells = document.querySelectorAll(
                `#puzzleGrid .cell.placed[data-placed-shape-id="${shapeId}"]`
            );

            // Remove all cells of this shape instance directly
            // This avoids issues where calculating origin/rotation might miss cells
            allPlacedCells.forEach(gridCell => {
                gridCell.classList.remove(color, 'placed', 'shade-alt',
                    'border-top', 'border-right', 'border-bottom', 'border-left',
                    'corner-tl', 'corner-tr', 'corner-br', 'corner-bl');
                gridCell.dataset.currentState = 'empty';
                delete gridCell.dataset.placedShapeId;
                delete gridCell.dataset.placedRotation;
            });

            // Add shape back to palette
            addShapeToPalette(shapeId, color, rotationIndex);

            // Update bars
            updatePuzzleBars();
        }

        // ============================================
        // MOBILE SUPPORT - Long Press & Double Tap Removal
        // ============================================

        // State for undo functionality
        let lastRemovedShape = null;
        let undoTimeout = null;

        // State for long-press detection
        let longPressState = {
            active: false,
            timer: null,
            cell: null,
            indicator: null
        };

        // State for double-tap detection
        let doubleTapState = {
            lastTapTime: 0,
            lastTapCell: null
        };

        const LONG_PRESS_DURATION = 500; // ms
        const DOUBLE_TAP_WINDOW = 300; // ms

        // Add touch handlers to grid cells for removal
        function addRemovalTouchHandlers(cell) {
            cell.addEventListener('touchstart', handleCellTouchStart, { passive: false });
            cell.addEventListener('touchend', handleCellTouchEnd);
            cell.addEventListener('touchmove', handleCellTouchMove, { passive: false });
            cell.addEventListener('touchcancel', cancelLongPress);
        }

        function handleCellTouchStart(e) {
            // Only in mobile mode or touch device
            if (!mobileMode && !DeviceCapabilities.hasTouch) return;

            const cell = e.target.closest('.cell');
            if (!cell || !cell.classList.contains('placed')) return;

            // Don't prevent default yet - we need to distinguish from scroll

            // Start long-press timer
            longPressState.cell = cell;
            longPressState.active = true;

            // Add visual indicator
            const indicator = document.createElement('div');
            indicator.className = 'long-press-indicator';
            cell.appendChild(indicator);
            longPressState.indicator = indicator;

            longPressState.timer = setTimeout(() => {
                if (longPressState.active && longPressState.cell === cell) {
                    // Long press detected - remove shape
                    indicator.classList.add('active');
                    setTimeout(() => {
                        removeShapeByCell(cell, true);
                        cancelLongPress();
                    }, 100);
                }
            }, LONG_PRESS_DURATION);
        }

        function handleCellTouchMove(e) {
            // Cancel long press if finger moved
            if (longPressState.active) {
                cancelLongPress();
            }
        }

        function handleCellTouchEnd(e) {
            const cell = e.target.closest('.cell');

            // Cancel any pending long press
            cancelLongPress();

            // Check for double-tap
            if (!cell || !cell.classList.contains('placed')) return;
            if (!mobileMode && !DeviceCapabilities.hasTouch) return;

            const now = Date.now();
            const timeSinceLastTap = now - doubleTapState.lastTapTime;

            if (timeSinceLastTap < DOUBLE_TAP_WINDOW && doubleTapState.lastTapCell === cell) {
                // Double tap detected - remove shape
                e.preventDefault();
                removeShapeByCell(cell, true);
                doubleTapState.lastTapTime = 0;
                doubleTapState.lastTapCell = null;
            } else {
                // First tap - record it
                doubleTapState.lastTapTime = now;
                doubleTapState.lastTapCell = cell;
            }
        }

        function cancelLongPress() {
            if (longPressState.timer) {
                clearTimeout(longPressState.timer);
                longPressState.timer = null;
            }
            if (longPressState.indicator) {
                longPressState.indicator.remove();
                longPressState.indicator = null;
            }
            longPressState.active = false;
            longPressState.cell = null;
        }

        function removeShapeByCell(cell, showUndo = false) {
            const shapeId = cell.dataset.placedShapeId;
            const rotationIndex = parseInt(cell.dataset.placedRotation);

            // Find color from cell class
            let color = null;
            for (const c of puzzleConfig.colors) {
                if (cell.classList.contains(c)) {
                    color = c;
                    break;
                }
            }
            if (!color) return;

            // Find the origin position of this shape
            const shapeData = SHAPE_LIBRARY[shapeId];
            const rotation = shapeData.rotations[rotationIndex];
            const cellRow = parseInt(cell.dataset.row);
            const cellCol = parseInt(cell.dataset.col);

            // Find origin by testing offsets
            let originRow = null, originCol = null;
            for (const [dr, dc] of rotation) {
                const testRow = cellRow - dr;
                const testCol = cellCol - dc;
                // Verify this is correct origin
                let valid = true;
                for (const [dr2, dc2] of rotation) {
                    const checkCell = document.querySelector(
                        `#puzzleGrid .cell[data-row="${testRow + dr2}"][data-col="${testCol + dc2}"]`
                    );
                    if (!checkCell || !checkCell.classList.contains('placed') ||
                        checkCell.dataset.placedShapeId !== shapeId) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    originRow = testRow;
                    originCol = testCol;
                    break;
                }
            }

            // Store for undo before removing
            if (showUndo && originRow !== null) {
                lastRemovedShape = {
                    shapeId,
                    color,
                    rotationIndex,
                    originRow,
                    originCol,
                    cells: rotation.map(([dr, dc]) => [originRow + dr, originCol + dc])
                };
            }

            // Find and remove all cells of this placed shape
            const allPlacedCells = document.querySelectorAll(
                `#puzzleGrid .cell.placed[data-placed-shape-id="${shapeId}"]`
            );

            allPlacedCells.forEach(gridCell => {
                gridCell.classList.remove(color, 'placed', 'shade-alt',
                    'border-top', 'border-right', 'border-bottom', 'border-left',
                    'corner-tl', 'corner-tr', 'corner-br', 'corner-bl');
                gridCell.dataset.currentState = 'empty';
                delete gridCell.dataset.placedShapeId;
                delete gridCell.dataset.placedRotation;
            });

            // Add shape back to palette
            addShapeToPalette(shapeId, color, rotationIndex);

            // Update bars
            updatePuzzleBars();

            // Show undo button
            if (showUndo && lastRemovedShape) {
                showUndoButton();
            }

            showToast('Shape removed', 'info', 1500);
        }

        function showUndoButton() {
            const undoBtn = document.getElementById('mobileUndoBtn');
            if (!undoBtn) return;

            // Clear any existing timeout
            if (undoTimeout) {
                clearTimeout(undoTimeout);
            }

            undoBtn.classList.add('visible');

            // Auto-hide after 5 seconds
            undoTimeout = setTimeout(() => {
                hideUndoButton();
            }, 5000);
        }

        function hideUndoButton() {
            const undoBtn = document.getElementById('mobileUndoBtn');
            if (undoBtn) {
                undoBtn.classList.remove('visible');
            }
            if (undoTimeout) {
                clearTimeout(undoTimeout);
                undoTimeout = null;
            }
        }

        function handleUndo() {
            if (!lastRemovedShape) {
                showToast('Nothing to undo', 'info', 1500);
                return;
            }

            const { shapeId, color, rotationIndex, originRow, originCol, cells } = lastRemovedShape;

            // Check if cells are still empty
            const shapeData = SHAPE_LIBRARY[shapeId];
            const rotation = shapeData.rotations[rotationIndex];
            const validity = checkPlacementValidity(originRow, originCol, rotation);

            if (!validity.valid) {
                showToast('Cannot undo - space is occupied', 'error', 2000);
                lastRemovedShape = null;
                hideUndoButton();
                return;
            }

            // Find and remove the shape from palette
            const paletteShape = document.querySelector(
                `#paletteShapes .palette-shape[data-shape-id="${shapeId}"][data-color="${color}"]`
            );
            if (paletteShape) {
                paletteShape.remove();
            }

            // Place the shape back
            placeShapeOnGrid(originRow, originCol, rotation, color, shapeId, rotationIndex);

            // Update bars
            updatePuzzleBars();

            // Clear undo state
            lastRemovedShape = null;
            hideUndoButton();

            showToast('Shape restored', 'success', 1500);
        }

        // Initialize undo button handler
        document.addEventListener('DOMContentLoaded', () => {
            const undoBtn = document.getElementById('mobileUndoBtn');
            if (undoBtn) {
                undoBtn.addEventListener('click', handleUndo);
                undoBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    handleUndo();
                });
            }
        });

        function addShapeToPalette(shapeId, color, placedRotationIndex) {
            const palette = document.getElementById('paletteShapes');

            // Look up the solution data from the current puzzle
            const solutionShapes = currentPuzzle.shapes[color] || [];
            const solutionShape = solutionShapes.find(s => s.shapeId === shapeId);

            const shapeEl = document.createElement('div');
            shapeEl.className = `palette-shape ${color}`;
            shapeEl.dataset.shapeId = shapeId;
            shapeEl.dataset.color = color;

            // Randomize display rotation (not the solution rotation)
            const shapeData = SHAPE_LIBRARY[shapeId];
            const randomDisplayRotation = Math.floor(Math.random() * shapeData.rotations.length);
            shapeEl.dataset.rotationIndex = randomDisplayRotation;

            // Store solution data if available (for hints to work)
            if (solutionShape) {
                shapeEl.dataset.solutionRotationIndex = solutionShape.rotationIndex;
                shapeEl.dataset.solutionRow = solutionShape.position[0];
                shapeEl.dataset.solutionCol = solutionShape.position[1];
            }

            shapeEl.style.cursor = 'grab';

            const rotation = shapeData.rotations[randomDisplayRotation];
            const bounds = getShapeBounds(rotation);

            const preview = document.createElement('div');
            preview.className = 'shape-preview-grid';
            preview.style.display = 'grid';
            preview.style.gridTemplateColumns = `repeat(${bounds.width}, 12px)`;
            preview.style.gridTemplateRows = `repeat(${bounds.height}, 12px)`;
            preview.style.gap = '1px';

            for (let r = 0; r < bounds.height; r++) {
                for (let c = 0; c < bounds.width; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = '12px';
                    cell.style.height = '12px';

                    const isShapeCell = rotation.some(([sr, sc]) => sr === r && sc === c);
                    if (isShapeCell) {
                        cell.className = `shape-preview-cell ${color}`;
                    } else {
                        cell.style.background = 'transparent';
                    }

                    preview.appendChild(cell);
                }
            }

            shapeEl.appendChild(preview);
            shapeEl.addEventListener('mousedown', handleShapeMouseDown);

            // Add touch handler for mobile support
            addTouchHandlerToShape(shapeEl);

            palette.appendChild(shapeEl);
        }

        function checkWinCondition() {
            if (!currentPuzzle) return;

            // Check if palette is empty
            const remainingShapes = document.querySelectorAll('#paletteShapes .palette-shape');
            if (remainingShapes.length > 0) return;

            // Check all requirements are met exactly
            const bars = document.querySelectorAll('.prescriptive-bar');

            for (const bar of bars) {
                if (bar.classList.contains('error')) return;

                const required = parseInt(bar.dataset.required);
                const filled = bar.querySelectorAll('.prescriptive-segment.filled').length;
                if (filled !== required) return;
            }

            // Win!
            showToast('Puzzle Complete! Congratulations!', 'success', 5000);
        }

        function clearCellsForPlacement(startRow, startCol, rotation) {
            // Clear any placed shapes from cells needed for this placement
            // Returns array of shapes that were removed (to add back to palette)
            const removedShapes = [];
            const cellsToProcess = new Set();

            // Collect all cells that need to be cleared
            for (const [dr, dc] of rotation) {
                const r = startRow + dr;
                const c = startCol + dc;
                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                );
                if (gridCell && gridCell.classList.contains('placed')) {
                    cellsToProcess.add(`${r},${c}`);
                }
            }

            // For each cell with a placed shape, find and remove the entire shape
            const processedShapes = new Set();
            cellsToProcess.forEach(cellKey => {
                const [r, c] = cellKey.split(',').map(Number);
                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                );
                if (!gridCell || !gridCell.classList.contains('placed')) return;

                const placedShapeId = gridCell.dataset.placedShapeId;
                const placedRotation = parseInt(gridCell.dataset.placedRotation);

                // Find the color
                let placedColor = null;
                for (const col of puzzleConfig.colors) {
                    if (gridCell.classList.contains(col)) {
                        placedColor = col;
                        break;
                    }
                }
                if (!placedColor) return;

                // Create unique key for this shape instance
                const shapeKey = `${placedShapeId}-${placedColor}-${r}-${c}`;
                if (processedShapes.has(shapeKey)) return;

                // Find all cells of this shape and get its origin
                const shapeData = SHAPE_LIBRARY[placedShapeId];
                const shapeRotation = shapeData.rotations[placedRotation];

                // Find origin by checking which offset makes this cell match
                let originRow = null, originCol = null;
                for (const [dr, dc] of shapeRotation) {
                    const testOriginR = r - dr;
                    const testOriginC = c - dc;
                    // Verify this origin works for all cells
                    let valid = true;
                    for (const [dr2, dc2] of shapeRotation) {
                        const checkCell = document.querySelector(
                            `#puzzleGrid .cell[data-row="${testOriginR + dr2}"][data-col="${testOriginC + dc2}"]`
                        );
                        if (!checkCell || !checkCell.classList.contains('placed') ||
                            checkCell.dataset.placedShapeId !== placedShapeId) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) {
                        originRow = testOriginR;
                        originCol = testOriginC;
                        break;
                    }
                }

                if (originRow === null) return;

                // Mark this shape as processed
                processedShapes.add(`${placedShapeId}-${placedColor}-${originRow}-${originCol}`);

                // Remove all cells of this shape
                for (const [dr, dc] of shapeRotation) {
                    const cellR = originRow + dr;
                    const cellC = originCol + dc;
                    const cell = document.querySelector(
                        `#puzzleGrid .cell[data-row="${cellR}"][data-col="${cellC}"]`
                    );
                    if (cell) {
                        cell.classList.remove(placedColor, 'placed', 'shade-alt',
                            'border-top', 'border-right', 'border-bottom', 'border-left',
                            'corner-tl', 'corner-tr', 'corner-br', 'corner-bl');
                                cell.dataset.currentState = 'empty';
                        delete cell.dataset.placedShapeId;
                        delete cell.dataset.placedRotation;
                    }
                }

                // Track removed shape to add back to palette
                removedShapes.push({
                    shapeId: placedShapeId,
                    color: placedColor,
                    rotationIndex: placedRotation
                });
            });

            return removedShapes;
        }

        function showOneHint() {
            if (!currentPuzzle) return;

            // Get remaining shapes from palette
            const remainingShapes = document.querySelectorAll('#paletteShapes .palette-shape');
            if (remainingShapes.length === 0) {
                showToast('No shapes left to hint!', 'info', 2000);
                return;
            }

            // Pick a random shape
            const randomIndex = Math.floor(Math.random() * remainingShapes.length);
            const shapeEl = remainingShapes[randomIndex];

            // Get solution position from data attributes
            const shapeId = shapeEl.dataset.shapeId;
            const color = shapeEl.dataset.color;
            // Use the SOLUTION rotation index, not the current display rotation
            const solutionRotationIndex = parseInt(shapeEl.dataset.solutionRotationIndex);
            const solutionRow = parseInt(shapeEl.dataset.solutionRow);
            const solutionCol = parseInt(shapeEl.dataset.solutionCol);

            // Get the rotation cells using the solution rotation
            const shapeData = SHAPE_LIBRARY[shapeId];
            const rotation = shapeData.rotations[solutionRotationIndex];

            // Clear any incorrectly placed shapes from the solution cells
            const removedShapes = clearCellsForPlacement(solutionRow, solutionCol, rotation);

            // Add removed shapes back to palette (with randomized display rotation)
            for (const shape of removedShapes) {
                addShapeToPalette(shape.shapeId, shape.color, shape.rotationIndex);
            }

            // Place the shape at its solution position with the solution rotation
            placeShapeOnGrid(solutionRow, solutionCol, rotation, color, shapeId, solutionRotationIndex);

            // Remove from palette
            shapeEl.remove();

            // Update bars after all changes
            updatePuzzleBars();

            showToast('Hint: placed one shape', 'info', 2000);

            // Check win condition
            checkWinCondition();
        }

        function showSolution() {
            if (!currentPuzzle) return;

            // First, clear ALL placed shapes from the grid
            const allPlacedCells = document.querySelectorAll('#puzzleGrid .cell.placed');
            allPlacedCells.forEach(cell => {
                for (const color of puzzleConfig.colors) {
                    cell.classList.remove(color);
                }
                cell.classList.remove('placed', 'shade-alt',
                    'border-top', 'border-right', 'border-bottom', 'border-left');
                cell.dataset.currentState = 'empty';
                delete cell.dataset.placedShapeId;
                delete cell.dataset.placedRotation;
            });

            // Clear the palette
            const palette = document.getElementById('paletteShapes');
            palette.innerHTML = '';

            // Place ALL shapes from the original puzzle at their solution positions
            for (const color of puzzleConfig.colors) {
                const shapes = currentPuzzle.shapes[color] || [];
                for (const shape of shapes) {
                    const shapeData = SHAPE_LIBRARY[shape.shapeId];
                    const rotation = shapeData.rotations[shape.rotationIndex];
                    placeShapeOnGrid(
                        shape.position[0],
                        shape.position[1],
                        rotation,
                        color,
                        shape.shapeId,
                        shape.rotationIndex
                    );
                }
            }

            // Update bars
            updatePuzzleBars();

            showToast('Solution revealed!', 'info', 3000);

            // Check win
            checkWinCondition();
        }

        function resetPuzzle() {
            if (currentPuzzle) {
                renderPuzzlePlayArea(currentPuzzle);
            }
        }

        // ============================================
        // BENCHMARK SYSTEM - Temporary Testing Infrastructure
        // ============================================

        // Solver metrics tracking
        let solverMetrics = {
            nodesExplored: 0,
            placementsTried: 0,
            backtracks: 0,
            startTime: 0,
            endTime: 0
        };

        function resetSolverMetrics() {
            solverMetrics = {
                nodesExplored: 0,
                placementsTried: 0,
                backtracks: 0,
                startTime: performance.now(),
                endTime: 0
            };
        }

        function finishSolverMetrics() {
            solverMetrics.endTime = performance.now();
            return {
                ...solverMetrics,
                timeMs: solverMetrics.endTime - solverMetrics.startTime
            };
        }

        // Instrumented solver that tracks metrics
        function instrumentedSolveForColor(color, placements, gridRows, gridCols, rowReqs, colReqs, forbiddenCells) {
            const solutions = [];
            const forbiddenSet = new Set(forbiddenCells.map(([r, c]) => `${r},${c}`));

            const validPlacements = placements.filter(p => {
                return !p.cells.some(([r, c]) => forbiddenSet.has(`${r},${c}`));
            });

            validPlacements.sort((a, b) => {
                const aMin = Math.min(...a.cells.map(([r, c]) => r * 100 + c));
                const bMin = Math.min(...b.cells.map(([r, c]) => r * 100 + c));
                return aMin - bMin;
            });

            const rowCounts = Array(gridRows).fill(0);
            const colCounts = Array(gridCols).fill(0);
            const usedCells = new Set();
            const currentPlacements = [];

            function backtrack(startIdx) {
                solverMetrics.nodesExplored++;

                if (countsMatch(rowCounts, colCounts, rowReqs, colReqs, color)) {
                    solutions.push({
                        placements: [...currentPlacements],
                        cells: Array.from(usedCells).map(s => s.split(',').map(Number))
                    });
                    if (solutions.length >= 1) return; // Stop at first solution for benchmark
                }

                if (countsExceed(rowCounts, colCounts, rowReqs, colReqs, color)) {
                    solverMetrics.backtracks++;
                    return;
                }

                for (let i = startIdx; i < validPlacements.length; i++) {
                    const placement = validPlacements[i];
                    solverMetrics.placementsTried++;

                    const overlaps = placement.cells.some(([r, c]) => usedCells.has(`${r},${c}`));
                    if (overlaps) continue;

                    currentPlacements.push(placement);
                    for (const [r, c] of placement.cells) {
                        usedCells.add(`${r},${c}`);
                        rowCounts[r]++;
                        colCounts[c]++;
                    }

                    backtrack(i + 1);

                    if (solutions.length >= 1) return;

                    currentPlacements.pop();
                    for (const [r, c] of placement.cells) {
                        usedCells.delete(`${r},${c}`);
                        rowCounts[r]--;
                        colCounts[c]--;
                    }
                }
            }

            backtrack(0);
            return solutions;
        }

        // Instrumented main solver
        function instrumentedRunSolver(gridRows, gridCols, gridState, rowReqs, colReqs, enabledShapes, colors) {
            resetSolverMetrics();

            // Collect all forbidden cells (blocked OR locked)
            const blockedCells = [];
            for (let r = 0; r < gridRows; r++) {
                for (let c = 0; c < gridCols; c++) {
                    const state = gridState[r][c] || 'empty';
                    // Treat both 'blocked' and 'locked-*' as forbidden
                    if (state === 'blocked' || (typeof state === 'string' && state.startsWith('locked-'))) {
                        blockedCells.push([r, c]);
                    }
                }
            }

            const allPlacements = generateAllPlacements(gridRows, gridCols, blockedCells, enabledShapes);

            if (allPlacements.length === 0) {
                return { success: false, metrics: finishSolverMetrics() };
            }

            let currentForbidden = [...blockedCells];
            const colorSolutions = {};

            for (const color of colors) {
                const hasReq = rowReqs.some(r => (r[color] || 0) > 0) || colReqs.some(c => (c[color] || 0) > 0);

                if (hasReq) {
                    const solutions = instrumentedSolveForColor(
                        color, allPlacements, gridRows, gridCols, rowReqs, colReqs, currentForbidden
                    );

                    if (solutions.length === 0) {
                        return { success: false, metrics: finishSolverMetrics() };
                    }

                    colorSolutions[color] = solutions[0];
                    currentForbidden = [...currentForbidden, ...solutions[0].cells];
                }
            }

            return { success: true, solutions: colorSolutions, metrics: finishSolverMetrics() };
        }

        // Difficulty presets - MUST MATCH UI setDifficulty() presets exactly
        const DIFFICULTY_PRESETS = {
            easy: { gridRows: 4, gridCols: 4, colors: ['green'], blockers: false, locks: false },
            medium: { gridRows: 5, gridCols: 5, colors: ['green', 'blue'], blockers: true, locks: false },
            hard: { gridRows: 6, gridCols: 6, colors: ['green', 'blue'], blockers: true, locks: true },
            expert: { gridRows: 7, gridCols: 7, colors: ['green', 'blue', 'red'], blockers: true, locks: true },
            master: { gridRows: 8, gridCols: 8, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: true }
        };

        // Generate all 80 combinations (uses ALL_COLORS defined earlier)
        function generateAllCombinations() {
            const combinations = [];
            const gridSizes = [4, 5, 6, 7, 8];
            const colorCounts = [1, 2, 3, 4];
            const blockerOptions = [false, true];
            const lockOptions = [false, true];

            for (const size of gridSizes) {
                for (const colorCount of colorCounts) {
                    for (const blockers of blockerOptions) {
                        for (const locks of lockOptions) {
                            const colors = ALL_COLORS.slice(0, colorCount);
                            const id = `${size}x${size}_${colorCount}c_${blockers ? 'B' : 'b'}_${locks ? 'L' : 'l'}`;
                            combinations.push({
                                id,
                                gridRows: size,
                                gridCols: size,
                                colors,
                                blockers,
                                locks
                            });
                        }
                    }
                }
            }
            return combinations;
        }

        const ALL_COMBINATIONS = generateAllCombinations();

        // Update mode info display
        function updateBenchmarkModeInfo() {
            const mode = document.getElementById('benchmarkMode').value;
            const samples = parseInt(document.getElementById('benchmarkSamples').value) || 10;
            const configs = mode === 'presets' ? 5 : 80;
            const total = configs * samples;
            document.getElementById('benchmarkModeInfo').textContent = `(${total} total puzzles)`;
        }

        // Toggle benchmark panel
        function toggleBenchmarkPanel() {
            const panel = document.getElementById('benchmarkPanel');
            panel.classList.toggle('visible');
        }

        // Clear benchmark results
        function clearBenchmarkResults() {
            document.getElementById('benchmarkResults').innerHTML =
                '<p style="color: #888;">Click "Run Benchmark" to generate puzzles at each difficulty and measure solver complexity.</p>';
        }

        // Run the full benchmark
        async function runBenchmark() {
            const mode = document.getElementById('benchmarkMode').value;
            const samplesPerConfig = parseInt(document.getElementById('benchmarkSamples').value) || 10;
            const progressDiv = document.getElementById('benchmarkProgress');
            const statusSpan = document.getElementById('benchmarkStatus');
            const progressFill = document.getElementById('benchmarkProgressFill');
            const resultsDiv = document.getElementById('benchmarkResults');

            progressDiv.style.display = 'block';
            resultsDiv.innerHTML = '<p>Running benchmark...</p>';

            // Suppress console logging during benchmark
            window.BENCHMARK_MODE = true;

            // Select configurations based on mode
            let configs;
            if (mode === 'presets') {
                configs = Object.entries(DIFFICULTY_PRESETS).map(([name, preset]) => ({
                    id: name,
                    ...preset
                }));
            } else {
                configs = ALL_COMBINATIONS;
            }

            const totalSteps = configs.length * samplesPerConfig;
            let currentStep = 0;

            const allResults = {};

            for (const config of configs) {
                const configId = config.id;
                const preset = config;
                const samples = [];

                for (let i = 0; i < samplesPerConfig; i++) {
                    currentStep++;
                    statusSpan.textContent = `${configId} (${i + 1}/${samplesPerConfig})`;
                    progressFill.style.width = ((currentStep / totalSteps) * 100) + '%';

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 10));

                    // Generate a puzzle with this difficulty
                    const puzzle = PuzzleGenerator.generate({
                        gridRows: preset.gridRows,
                        gridCols: preset.gridCols,
                        colors: preset.colors,
                        blockers: preset.blockers,
                        locks: preset.locks
                    });

                    if (!puzzle) {
                        samples.push({
                            success: false,
                            timeMs: 0,
                            nodesExplored: 0,
                            failReason: 'generation'
                        });
                        continue;
                    }

                    // Build the requirements and grid state for the solver
                    const gridState = [];
                    for (let r = 0; r < preset.gridRows; r++) {
                        gridState[r] = [];
                        for (let c = 0; c < preset.gridCols; c++) {
                            gridState[r][c] = 'empty';
                        }
                    }

                    // Add blockers
                    for (const [r, c] of puzzle.blockers || []) {
                        gridState[r][c] = 'blocked';
                    }

                    // Add locked cells and track their contributions
                    const lockedContributions = {
                        rows: Array(preset.gridRows).fill(null).map(() => ({})),
                        cols: Array(preset.gridCols).fill(null).map(() => ({}))
                    };

                    // Initialize contributions for all colors
                    for (let r = 0; r < preset.gridRows; r++) {
                        for (const color of preset.colors) {
                            lockedContributions.rows[r][color] = 0;
                        }
                    }
                    for (let c = 0; c < preset.gridCols; c++) {
                        for (const color of preset.colors) {
                            lockedContributions.cols[c][color] = 0;
                        }
                    }

                    // Mark locked cells as forbidden and count their contributions
                    for (const color of preset.colors) {
                        const colorLocks = puzzle.locks[color] || [];
                        for (const [r, c] of colorLocks) {
                            gridState[r][c] = `locked-${color}`;
                            lockedContributions.rows[r][color]++;
                            lockedContributions.cols[c][color]++;
                        }
                    }

                    // Adjust requirements by subtracting locked cell contributions
                    // (solver only needs to place shapes to cover the remaining requirement)
                    const adjustedRowReqs = puzzle.requirements.rows.map((req, r) => {
                        const adjusted = {};
                        for (const color of preset.colors) {
                            adjusted[color] = (req[color] || 0) - (lockedContributions.rows[r][color] || 0);
                        }
                        return adjusted;
                    });

                    const adjustedColReqs = puzzle.requirements.cols.map((req, c) => {
                        const adjusted = {};
                        for (const color of preset.colors) {
                            adjusted[color] = (req[color] || 0) - (lockedContributions.cols[c][color] || 0);
                        }
                        return adjusted;
                    });

                    const rowReqs = adjustedRowReqs;
                    const colReqs = adjustedColReqs;

                    // Get enabled shapes from the puzzle
                    const enabledShapes = new Set();
                    for (const color of preset.colors) {
                        const shapes = puzzle.shapes[color] || [];
                        for (const shape of shapes) {
                            enabledShapes.add(shape.shapeId);
                        }
                    }

                    // Run instrumented solver
                    const result = instrumentedRunSolver(
                        preset.gridRows,
                        preset.gridCols,
                        gridState,
                        rowReqs,
                        colReqs,
                        Array.from(enabledShapes),
                        preset.colors
                    );

                    samples.push({
                        success: result.success,
                        timeMs: result.metrics.timeMs,
                        nodesExplored: result.metrics.nodesExplored,
                        placementsTried: result.metrics.placementsTried,
                        backtracks: result.metrics.backtracks,
                        failReason: result.success ? null : 'solver'
                    });
                }

                // Calculate statistics
                const successfulSamples = samples.filter(s => s.success);
                const generationFailures = samples.filter(s => !s.success && s.failReason === 'generation').length;
                const solverFailures = samples.filter(s => !s.success && s.failReason !== 'generation').length;
                const stats = {
                    total: samples.length,
                    successful: successfulSamples.length,
                    generationFailures,
                    solverFailures,
                    avgTimeMs: successfulSamples.length > 0 ?
                        successfulSamples.reduce((a, b) => a + b.timeMs, 0) / successfulSamples.length : 0,
                    medianTimeMs: successfulSamples.length > 0 ?
                        getMedian(successfulSamples.map(s => s.timeMs)) : 0,
                    avgNodes: successfulSamples.length > 0 ?
                        successfulSamples.reduce((a, b) => a + b.nodesExplored, 0) / successfulSamples.length : 0,
                    medianNodes: successfulSamples.length > 0 ?
                        getMedian(successfulSamples.map(s => s.nodesExplored)) : 0,
                    avgPlacements: successfulSamples.length > 0 ?
                        successfulSamples.reduce((a, b) => a + b.placementsTried, 0) / successfulSamples.length : 0,
                    maxNodes: successfulSamples.length > 0 ?
                        Math.max(...successfulSamples.map(s => s.nodesExplored)) : 0,
                    minNodes: successfulSamples.length > 0 ?
                        Math.min(...successfulSamples.map(s => s.nodesExplored)) : 0
                };

                allResults[configId] = { preset, stats, samples };
            }

            // Re-enable console logging
            window.BENCHMARK_MODE = false;

            progressDiv.style.display = 'none';
            displayBenchmarkResults(allResults, mode);
        }

        function getMedian(arr) {
            if (arr.length === 0) return 0;
            const sorted = [...arr].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        function displayBenchmarkResults(results, mode) {
            const resultsDiv = document.getElementById('benchmarkResults');

            // Sort by median nodes to see actual difficulty
            const sortedByComplexity = Object.entries(results)
                .sort((a, b) => b[1].stats.medianNodes - a[1].stats.medianNodes);

            let html = `
                <h3 style="color: #39ff14; margin-bottom: 10px;">Results Summary (${mode === 'presets' ? 'Presets' : 'All 80 Combinations'})</h3>
                <p style="color: #888; margin-bottom: 10px; font-size: 11px;">
                    Higher nodes explored = more backtracking = potentially harder puzzle.<br>
                    "Gen Fail" = puzzle generation failed. "Solve Fail" = solver couldn't find solution.
                </p>
            `;

            if (mode === 'presets') {
                // Original presets display
                html += `
                    <h4 style="color: #aaa; margin: 15px 0 10px;">Presets Being Tested:</h4>
                    <table style="margin-bottom: 15px; font-size: 11px;">
                        <tr><th>Difficulty</th><th>Grid</th><th>Colors</th><th>Blockers</th><th>Locks</th></tr>
                        ${Object.entries(DIFFICULTY_PRESETS).map(([name, p]) =>
                            `<tr class="difficulty-${name}">
                                <td>${name}</td>
                                <td>${p.gridRows}x${p.gridCols}</td>
                                <td>${p.colors.length} (${p.colors.join(', ')})</td>
                                <td>${p.blockers ? 'âœ“' : 'âœ—'}</td>
                                <td>${p.locks ? 'âœ“' : 'âœ—'}</td>
                            </tr>`
                        ).join('')}
                    </table>
                `;
            }

            html += `
                <h4 style="color: #aaa; margin: 15px 0 10px;">Ranked by Actual Complexity (median nodes explored):</h4>
                <table style="font-size: ${mode === 'all' ? '10px' : '12px'};">
                    <tr>
                        <th>Rank</th>
                        <th>Config</th>
                        <th>Grid</th>
                        <th>Colors</th>
                        <th>B</th>
                        <th>L</th>
                        <th>Success</th>
                        <th>Median Nodes</th>
                        <th>Avg Time (ms)</th>
                        <th>Range</th>
                    </tr>
            `;

            let rank = 1;
            for (const [configId, data] of sortedByComplexity) {
                const diffClass = mode === 'presets' ? `difficulty-${configId}` : '';
                const successRate = data.stats.successful / data.stats.total;
                const successColor = successRate >= 0.8 ? '#39ff14' : successRate >= 0.5 ? '#ff9f1c' : '#ff3939';
                html += `
                    <tr>
                        <td><strong>#${rank}</strong></td>
                        <td class="${diffClass}" style="font-family: monospace;">${configId}</td>
                        <td>${data.preset.gridRows}x${data.preset.gridCols}</td>
                        <td>${data.preset.colors.length}</td>
                        <td>${data.preset.blockers ? 'âœ“' : 'âœ—'}</td>
                        <td>${data.preset.locks ? 'âœ“' : 'âœ—'}</td>
                        <td style="color: ${successColor};">${data.stats.successful}/${data.stats.total}</td>
                        <td><strong>${Math.round(data.stats.medianNodes)}</strong></td>
                        <td>${data.stats.avgTimeMs.toFixed(2)}</td>
                        <td>${data.stats.minNodes} - ${data.stats.maxNodes}</td>
                    </tr>
                `;
                rank++;
            }

            html += '</table>';

            if (mode === 'presets') {
                // Add comparison with expected order (only for presets mode)
                const expectedOrder = ['easy', 'medium', 'hard', 'expert', 'master'];
                const actualOrder = sortedByComplexity.map(([d]) => d);

                html += `
                    <h4 style="color: #aaa; margin: 20px 0 10px;">Order Comparison:</h4>
                    <div style="display: flex; gap: 20px; margin-bottom: 15px;">
                        <div>
                            <strong style="color: #888;">Expected (current labels):</strong><br>
                            ${expectedOrder.map((d, i) => `${i + 1}. ${d}`).join('<br>')}
                        </div>
                        <div>
                            <strong style="color: #39ff14;">Actual (by complexity):</strong><br>
                            ${actualOrder.map((d, i) => `${i + 1}. ${d}`).join('<br>')}
                        </div>
                    </div>
                `;
            } else {
                // For all combinations mode, show summary statistics
                const byGridSize = {};
                const byColorCount = {};
                const byBlockers = { true: [], false: [] };
                const byLocks = { true: [], false: [] };

                for (const [configId, data] of Object.entries(results)) {
                    const grid = `${data.preset.gridRows}x${data.preset.gridCols}`;
                    const colors = data.preset.colors.length;

                    if (!byGridSize[grid]) byGridSize[grid] = [];
                    byGridSize[grid].push(data.stats.medianNodes);

                    if (!byColorCount[colors]) byColorCount[colors] = [];
                    byColorCount[colors].push(data.stats.medianNodes);

                    byBlockers[data.preset.blockers].push(data.stats.medianNodes);
                    byLocks[data.preset.locks].push(data.stats.medianNodes);
                }

                const calcMedian = arr => {
                    if (arr.length === 0) return 0;
                    const sorted = [...arr].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
                };

                html += `
                    <h4 style="color: #aaa; margin: 20px 0 10px;">Factor Analysis (median of medians):</h4>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 15px;">
                        <div>
                            <strong style="color: #888;">By Grid Size:</strong><br>
                            ${Object.entries(byGridSize).map(([grid, nodes]) =>
                                `${grid}: ${Math.round(calcMedian(nodes))} nodes`
                            ).join('<br>')}
                        </div>
                        <div>
                            <strong style="color: #888;">By Color Count:</strong><br>
                            ${Object.entries(byColorCount).map(([count, nodes]) =>
                                `${count} color${count > 1 ? 's' : ''}: ${Math.round(calcMedian(nodes))} nodes`
                            ).join('<br>')}
                        </div>
                        <div>
                            <strong style="color: #888;">By Blockers:</strong><br>
                            With: ${Math.round(calcMedian(byBlockers[true]))} nodes<br>
                            Without: ${Math.round(calcMedian(byBlockers[false]))} nodes
                        </div>
                        <div>
                            <strong style="color: #888;">By Locks:</strong><br>
                            With: ${Math.round(calcMedian(byLocks[true]))} nodes<br>
                            Without: ${Math.round(calcMedian(byLocks[false]))} nodes
                        </div>
                    </div>
                `;
            }

            // Show observation about order (no conclusions - just data)
            html += `
                <div style="padding: 15px; background: rgba(100, 100, 100, 0.2); border: 1px solid #666; border-radius: 6px; margin-top: 15px;">
                    <strong style="color: #aaa;">ðŸ“Š Data collected - review before drawing conclusions</strong>
                    <p style="color: #888; margin: 10px 0 0; font-size: 12px;">
                        Check "Gen Fail" column - high generation failures may skew results.<br>
                        Only puzzles that successfully generated AND were solved are counted in node stats.
                    </p>
                </div>
            `;

            // Add detailed stats table (only for presets mode - too verbose for 80 configs)
            if (mode === 'presets') {
                html += `
                    <h4 style="color: #aaa; margin: 20px 0 10px;">Detailed Statistics:</h4>
                    <table>
                        <tr>
                            <th>Difficulty</th>
                            <th>Success</th>
                            <th>Gen Fail</th>
                            <th>Solve Fail</th>
                            <th>Avg Nodes</th>
                            <th>Avg Placements</th>
                            <th>Median Time (ms)</th>
                        </tr>
                `;

                for (const [configId, data] of Object.entries(results)) {
                    const diffClass = `difficulty-${configId}`;
                    html += `
                        <tr>
                            <td class="${diffClass}">${configId}</td>
                            <td>${data.stats.successful}/${data.stats.total}</td>
                            <td style="color: #ff9f1c;">${data.stats.generationFailures}</td>
                            <td style="color: #ff3939;">${data.stats.solverFailures}</td>
                            <td>${Math.round(data.stats.avgNodes)}</td>
                            <td>${Math.round(data.stats.avgPlacements)}</td>
                            <td>${data.stats.medianTimeMs.toFixed(2)}</td>
                        </tr>
                    `;
                }

                html += '</table>';
            } else {
                // For all combinations mode, show failure summary
                const failedConfigs = Object.entries(results)
                    .filter(([_, data]) => data.stats.generationFailures > 0 || data.stats.solverFailures > 0)
                    .sort((a, b) => (b[1].stats.generationFailures + b[1].stats.solverFailures) -
                                    (a[1].stats.generationFailures + a[1].stats.solverFailures));

                if (failedConfigs.length > 0) {
                    html += `
                        <h4 style="color: #aaa; margin: 20px 0 10px;">Configurations with Failures (${failedConfigs.length}):</h4>
                        <table style="font-size: 10px;">
                            <tr>
                                <th>Config</th>
                                <th>Gen Fail</th>
                                <th>Solve Fail</th>
                                <th>Success Rate</th>
                            </tr>
                    `;

                    for (const [configId, data] of failedConfigs) {
                        const successRate = ((data.stats.successful / data.stats.total) * 100).toFixed(0);
                        html += `
                            <tr>
                                <td style="font-family: monospace;">${configId}</td>
                                <td style="color: #ff9f1c;">${data.stats.generationFailures}</td>
                                <td style="color: #ff3939;">${data.stats.solverFailures}</td>
                                <td>${successRate}%</td>
                            </tr>
                        `;
                    }

                    html += '</table>';
                } else {
                    html += '<p style="color: #39ff14; margin-top: 15px;">All configurations had 100% success rate.</p>';
                }
            }

            resultsDiv.innerHTML = html;
        }

        window.onload = function() {
            generateGrid();
            renderShapeSelector();
            setTimeout(updateSliderToggle, 0);

            // Update benchmark mode info when samples change
            const samplesInput = document.getElementById('benchmarkSamples');
            if (samplesInput) {
                samplesInput.addEventListener('input', updateBenchmarkModeInfo);
            }
        };
    </script>
</body>
</html>
