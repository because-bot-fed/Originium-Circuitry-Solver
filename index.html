<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Originium Circuitry Solver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', sans-serif;
            background: #0a0a0f;
            min-height: 100vh;
            color: #c8c8c8;
            padding: 25px 20px;
            user-select: none;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 15px;
            font-weight: 500;
            font-size: 1.3rem;
            color: #ffffff;
            letter-spacing: 0.5px;
        }

        /* Mode Toggle */
        .mode-toggle-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-toggle {
            display: inline-flex;
            background: #0a0a0a;
            border-radius: 4px;
            padding: 4px;
            border: 1px solid #222;
        }

        .mode-toggle-btn {
            padding: 10px 32px;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: transparent;
            border: none;
            color: #444;
            cursor: pointer;
            border-radius: 2px;
            transition: all 0.2s;
        }

        .mode-toggle-btn:hover {
            color: #666;
        }

        .mode-toggle-btn.active {
            background: linear-gradient(135deg, #1a3a1a, #2d5a2d);
            color: #39ff14;
            box-shadow: 0 2px 8px rgba(57, 255, 20, 0.2);
        }

        h2 {
            font-size: 0.85rem;
            font-weight: 500;
            color: #888;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Configuration Panel */
        .config-panel {
            display: flex;
            justify-content: center;
            gap: 25px;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .config-group {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .config-group label {
            font-size: 0.85rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .config-group input[type="number"] {
            width: 60px;
            padding: 10px 12px;
            border: 1px solid #222;
            border-radius: 2px;
            background: #111;
            color: #fff;
            font-size: 1rem;
            text-align: center;
            transition: border-color 0.2s;
        }

        .config-group input[type="number"]:focus {
            outline: none;
            border-color: #444;
        }

        .btn {
            padding: 10px 24px;
            border: none;
            border-radius: 2px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #333;
        }

        .btn-primary:hover {
            background: #252525;
            border-color: #444;
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10001;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 12px 20px;
            color: #fff;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            animation: toastIn 0.3s ease;
            max-width: 350px;
        }

        .toast.success {
            border-color: #39ff14;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a2a0a 100%);
        }

        .toast.error {
            border-color: #ff3939;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a0a0a 100%);
        }

        .toast.info {
            border-color: #00bfff;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a1a2a 100%);
        }

        .toast.fade-out {
            animation: toastOut 0.3s ease forwards;
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateX(50px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes toastOut {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(50px); }
        }

        .btn-solve {
            background: #1a3a1a;
            color: #39ff14;
            border: 1px solid #2d5a2d;
        }

        .btn-solve:hover {
            background: #224422;
            border-color: #3d7a3d;
        }

        .btn-clear {
            background: #111;
            color: #888;
            border: 1px solid #222;
        }

        .btn-clear:hover {
            background: #1a1a1a;
            color: #aaa;
        }

        /* Puzzle Area */
        .puzzle-area {
            display: flex;
            justify-content: center;
            overflow-x: auto;
            padding: 10px 0;
            gap: 20px;
        }

        .puzzle-wrapper {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
        }

        /* Shape Selector Panel */
        .shape-selector {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 10px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #1a1a1a;
            align-self: flex-start;
        }

        .shape-selector-title {
            font-size: 0.65rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 2px;
            text-align: center;
            grid-column: span 2;
        }

        .shape-selector-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .shape-selector-item {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
            background: #111;
            border-radius: 2px;
            border: 2px solid #222;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0.4;
        }

        .shape-selector-item:hover {
            background: #161616;
            border-color: #333;
        }

        .shape-selector-item.active {
            opacity: 1;
            border-color: #39ff14;
            background: #0a1a0a;
        }

        .shape-selector-item .shape-mini-grid {
            display: grid;
            gap: 1px;
        }

        .shape-selector-item .shape-mini-cell {
            width: 10px;
            height: 10px;
            background: #222;
            border-radius: 0;
        }

        .shape-selector-item .shape-mini-cell.filled {
            background: #39ff14;
        }

        .shape-selector-item.active .shape-mini-cell.filled {
            background: linear-gradient(145deg, #39ff14, #32cd32);
        }

        /* Puzzle Mode Styles */
        .puzzle-config-panel {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #1a1a1a;
        }

        .puzzle-config-panel h2 {
            text-align: center;
            font-size: 1rem;
            color: #888;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .puzzle-config-panel h3 {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .puzzle-difficulty-selector {
            margin-bottom: 25px;
        }

        .difficulty-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 10px 20px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            color: #666;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficulty-btn:hover {
            background: #1a1a1a;
            color: #888;
        }

        .difficulty-btn.active {
            background: #1a3a1a;
            color: #39ff14;
            border-color: #2d5a2d;
        }

        .puzzle-custom-config {
            margin-bottom: 25px;
        }

        .custom-config-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-item label {
            font-size: 0.75rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .size-inputs {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .size-inputs input {
            width: 60px;
            padding: 8px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            color: #fff;
            text-align: center;
        }

        .size-inputs span {
            color: #444;
        }

        .color-toggles {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .color-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            font-size: 0.75rem;
            color: #666;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-toggle input {
            display: none;
        }

        .color-toggle.green.active { background: #1a3a1a; color: #39ff14; border-color: #2d5a2d; }
        .color-toggle.blue.active { background: #1a2a4a; color: #00bfff; border-color: #2d4a7a; }
        .color-toggle.red.active { background: #3a1a1a; color: #ff3939; border-color: #5a2d2d; }
        .color-toggle.purple.active { background: #2a1a3a; color: #bf39ff; border-color: #4a2d5a; }

        .feature-toggles {
            display: flex;
            gap: 15px;
        }

        .feature-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: #888;
            cursor: pointer;
        }

        .feature-toggle input {
            accent-color: #39ff14;
        }

        .btn-generate-puzzle {
            width: 100%;
            padding: 14px;
            background: #1a3a1a;
            color: #39ff14;
            border: 1px solid #2d5a2d;
            border-radius: 2px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-generate-puzzle:hover {
            background: #224422;
            border-color: #3d7a3d;
        }

        .puzzle-play-area {
            margin-top: 20px;
        }

        .puzzle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .puzzle-main {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        .puzzle-grid-area {
            display: flex;
            flex-direction: column;
        }

        .puzzle-grid-row {
            display: flex;
        }

        .puzzle-grid {
            background: #0f0f0f;
            border: 1px solid #1a1a1a;
            border-radius: 2px;
        }

        .puzzle-col-req {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 4px;
        }

        .puzzle-row-req {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            padding-right: 4px;
        }

        .prescriptive-bar {
            --green-accent: #39ff14;
            --blue-accent: #00bfff;
            --red-accent: #ff3939;
            --purple-accent: #bf39ff;
        }

        .prescriptive-segment {
            background: transparent;
            transition: background 0.2s;
        }

        .prescriptive-segment.filled {
            background: currentColor;
        }

        .prescriptive-bar.green .prescriptive-segment { border-color: #39ff14; }
        .prescriptive-bar.green .prescriptive-segment.filled { background: #39ff14; }
        .prescriptive-bar.blue .prescriptive-segment { border-color: #00bfff; }
        .prescriptive-bar.blue .prescriptive-segment.filled { background: #00bfff; }
        .prescriptive-bar.red .prescriptive-segment { border-color: #ff3939; }
        .prescriptive-bar.red .prescriptive-segment.filled { background: #ff3939; }
        .prescriptive-bar.purple .prescriptive-segment { border-color: #bf39ff; }
        .prescriptive-bar.purple .prescriptive-segment.filled { background: #bf39ff; }

        .prescriptive-bar.error {
            background: linear-gradient(to top, rgba(255, 0, 0, 0.3), transparent);
            animation: error-pulse 1s ease-in-out infinite;
        }

        /* Drag placement highlighting */
        .cell.placement-valid {
            background: rgba(57, 255, 20, 0.3) !important;
            box-shadow: inset 0 0 10px rgba(57, 255, 20, 0.5);
        }

        .cell.placement-invalid {
            background: rgba(255, 57, 57, 0.3) !important;
            box-shadow: inset 0 0 10px rgba(255, 57, 57, 0.5);
        }

        .cell.placed {
            cursor: pointer;
        }

        /* Legacy border logic removed - see .cell definition */

        #drag-ghost .cell {
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .puzzle-shape-palette {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 2px;
            padding: 15px;
            min-width: 120px;
        }

        .puzzle-shape-palette h3 {
            font-size: 0.75rem;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            text-align: center;
        }

        .palette-shapes {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .palette-shape {
            padding: 8px;
            background: #111;
            border: 2px solid #222;
            border-radius: 2px;
            cursor: grab;
            transition: all 0.2s;
        }

        .palette-shape:hover {
            background: #1a1a1a;
            border-color: #333;
        }

        .palette-shape.green { border-color: #1a3a1a; }
        .palette-shape.green:hover { border-color: #39ff14; }
        .palette-shape.blue { border-color: #1a2a4a; }
        .palette-shape.blue:hover { border-color: #00bfff; }
        .palette-shape.red { border-color: #3a1a1a; }
        .palette-shape.red:hover { border-color: #ff3939; }
        .palette-shape.purple { border-color: #2a1a3a; }
        .palette-shape.purple:hover { border-color: #bf39ff; }

        .palette-shape.placed {
            opacity: 0.3;
            pointer-events: none;
        }

        .shape-preview-cell {
            background: #333;
            border: 1px solid #444;
        }
        .shape-preview-cell.green { background: #1a5c1a; border-color: #39ff14; }
        .shape-preview-cell.blue { background: #0066a0; border-color: #00bfff; }
        .shape-preview-cell.red { background: #8b1a1a; border-color: #ff3939; }
        .shape-preview-cell.purple { background: #5c1a8b; border-color: #bf39ff; }

        .puzzle-actions {
            display: flex;
            gap: 12px;
        }

        /* Hide Blue toggle button */
        .hide-blue-btn {
            margin-top: 8px;
            padding: 6px 10px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #111;
            border: 1px solid #222;
            border-radius: 2px;
            color: #666;
            cursor: pointer;
            transition: all 0.15s;
            width: 100%;
        }

        .hide-blue-btn:hover {
            background: #1a1a1a;
            color: #888;
        }

        .hide-blue-btn.active {
            background: #1a2a4a;
            color: #00bfff;
            border-color: #00bfff;
        }

        /* Shape count badge */
        .shape-selector-item {
            position: relative;
        }

        .shape-count-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #39ff14, #32cd32);
            color: #000;
            font-size: 0.7rem;
            font-weight: 700;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.2s ease;
        }

        .shape-selector-item.active .shape-count-badge {
            opacity: 1;
            transform: scale(1);
        }

        /* Sliding word toggle */
        .input-mode-slider {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .slider-toggle {
            display: inline-flex;
            align-items: center;
            background: #0a0a0a;
            border-radius: 4px;
            padding: 5px;
            border: 1px solid #222;
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .slider-option {
            padding: 10px 28px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #444;
            border-radius: 2px;
            transition: color 0.25s ease;
            z-index: 1;
            position: relative;
        }

        .slider-option.active {
            color: #fff;
        }

        .slider-bg {
            position: absolute;
            top: 5px;
            height: calc(100% - 10px);
            background: linear-gradient(135deg, #1a3a1a, #2d5a2d);
            border-radius: 2px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 0;
            box-shadow: 0 2px 8px rgba(57, 255, 20, 0.2);
        }

        .bar-input {
            display: flex;
            flex-direction: column-reverse;
            gap: 1px;
            justify-content: flex-end;
            background: transparent;
            padding: 0;
        }

        .bar-segment {
            border-radius: 1px;
            cursor: pointer;
            transition: all 0.1s;
            background: transparent;
        }

        .bar-input.green .bar-segment {
            border: 2px solid #39ff14;
        }

        .bar-input.green .bar-segment:hover {
            background: rgba(57, 255, 20, 0.2);
        }

        .bar-input.green .bar-segment.filled {
            background: #39ff14;
        }

        .bar-input.blue .bar-segment {
            border: 2px solid #00bfff;
        }

        .bar-input.blue .bar-segment:hover {
            background: rgba(0, 191, 255, 0.2);
        }

        .bar-input.blue .bar-segment.filled {
            background: #00bfff;
        }

        .bar-input.red .bar-segment {
            border: 2px solid #ff3939;
        }

        .bar-input.red .bar-segment:hover {
            background: rgba(255, 57, 57, 0.2);
        }

        .bar-input.red .bar-segment.filled {
            background: #ff3939;
        }

        .bar-input.purple .bar-segment {
            border: 2px solid #bf39ff;
        }

        .bar-input.purple .bar-segment:hover {
            background: rgba(191, 57, 255, 0.2);
        }

        .bar-input.purple .bar-segment.filled {
            background: #bf39ff;
        }

        /* Bar error state */
        .bar-input.error {
            background: linear-gradient(to top, rgba(255, 0, 0, 0.3), transparent);
            border-radius: 2px;
            animation: error-pulse 1s ease-in-out infinite;
        }

        @keyframes error-pulse {
            0%, 100% { box-shadow: 0 0 5px rgba(255, 0, 0, 0.3); }
            50% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.5); }
        }

        /* Column bar inputs - vertical bars side by side */
        .col-req .bar-input {
            width: 33px;
            height: 60px;
        }

        /* Row bar inputs - horizontal bars stacked vertically, fill from right */
        .row-req .bar-input {
            width: 60px;
            height: 33px;
            flex-direction: row-reverse;
        }

        /* Column Requirements - ABOVE the grid */
        .col-requirements {
            display: flex;
            gap: 0;
            margin-bottom: 0;
        }

        .col-req-spacer {
            flex-shrink: 0;
        }

        .col-req {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-end;
            gap: 1px;
            width: 68px;
        }

        /* Custom Stepper Control */
        .stepper {
            display: flex;
            flex-direction: column;
            border-radius: 2px;
            overflow: hidden;
            background: #0a0a0a;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .stepper:hover {
            background: #0f0f0f;
        }

        .stepper.green {
            border-color: #1a3a1a;
        }

        .stepper.green:hover {
            border-color: #2a4a2a;
        }

        .stepper.blue {
            border-color: #1a2a4a;
        }

        .stepper.blue:hover {
            border-color: #2a3a5a;
        }

        .stepper-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s;
            background: transparent;
        }

        .stepper-btn:hover {
            background: rgba(255,255,255,0.05);
        }

        .stepper-btn:active {
            background: rgba(255,255,255,0.1);
        }

        .stepper-btn svg {
            width: 20px;
            height: 20px;
            opacity: 0.4;
            transition: opacity 0.15s;
        }

        .stepper-btn:hover svg {
            opacity: 0.7;
        }

        .stepper.green .stepper-btn svg {
            fill: #39ff14;
        }

        .stepper.blue .stepper-btn svg {
            fill: #00bfff;
        }

        .stepper-value {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            font-weight: 600;
            background: transparent;
        }

        .stepper.green .stepper-value {
            color: #39ff14;
        }

        .stepper.blue .stepper-value {
            color: #00bfff;
        }

        .stepper.red .stepper-btn svg {
            fill: #ff3939;
        }

        .stepper.red .stepper-value {
            color: #ff3939;
        }

        .stepper.purple .stepper-btn svg {
            fill: #bf39ff;
        }

        .stepper.purple .stepper-value {
            color: #bf39ff;
        }

        /* Column stepper - vertical orientation */
        .col-req .stepper {
            width: 100%;
            height: 60px;
        }

        .col-req .stepper-btn {
            height: 17px;
        }

        .col-req .stepper-value {
            height: 26px;
            font-size: 1.1rem;
        }

        /* Row stepper - vertical orientation but wider */
        .row-req .stepper {
            width: 51px;
            height: 100%;
        }

        .row-req .stepper-btn {
            height: 19px;
        }

        .row-req .stepper-value {
            flex: 1;
            font-size: 1.1rem;
        }

        /* Grid Container */
        .grid-row {
            display: flex;
            align-items: stretch;
            gap: 0;
        }

        /* Row Requirements - LEFT of the grid */
        .row-requirements {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .row-req {
            display: flex;
            flex-direction: column;
            gap: 1px;
            height: 68px;
            justify-content: center;
            align-items: center;
        }

        /* Grid */
        .grid {
            display: grid;
            gap: 0;
            background: #0f0f0f;
            padding: 0;
            border-radius: 2px;
            border: 1px solid #1a1a1a;
        }

        .cell {
            width: 68px;
            height: 68px;
            /* Variables for theming and borders */
            --bg-color: #111;
            --border-color: #1a1a1a;
            
            /* Border Shadows - Color Layer (3px) */
            --bs-t-c: 0 0 0 0 transparent;
            --bs-r-c: 0 0 0 0 transparent;
            --bs-b-c: 0 0 0 0 transparent;
            --bs-l-c: 0 0 0 0 transparent;
            
            /* Border Shadows - Black Layer (3px + 4px = 7px) */
            --bs-t-b: 0 0 0 0 transparent;
            --bs-r-b: 0 0 0 0 transparent;
            --bs-b-b: 0 0 0 0 transparent;
            --bs-l-b: 0 0 0 0 transparent;

            /* Corner Patching Variables - Default to none */
            --c-tl: none;
            --c-tr: none;
            --c-bl: none;
            --c-br: none;

            /* Default Grid Line */
            --grid-line: inset 0 0 0 1px #1a1a1a;

            background: var(--bg-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.15s ease;
            /* Removed CSS border to prevent miter issues */
            position: relative;
            z-index: 1;
            
            /* Only grid line on the cell itself */
            box-shadow: var(--grid-line); 
        }

        /* Corner Patch Definitions: Mitered joints for Inner Corners 
           (Reduced size to 2.0px/5.0px to prevent visual bulging) */
        .cell.corner-tl { --c-tl: linear-gradient(135deg, var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }
        .cell.corner-tr { --c-tr: linear-gradient(225deg, var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }
        .cell.corner-br { --c-br: linear-gradient(315deg, var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }
        .cell.corner-bl { --c-bl: linear-gradient(45deg,  var(--border-color) 1.55px, #000 1.55px, #000 4px, transparent 4px); }

        /* Render Borders and Corners on ::before for Colored Cells */
        .cell.green::before, .cell.blue::before, .cell.red::before, .cell.purple::before {
            content: '';
            position: absolute;
            inset: 0;
            background: transparent;
            pointer-events: none;
            z-index: 2; /* Above background */
            display: block !important;
            
            /* Borders */
            box-shadow: 
                var(--bs-t-c), var(--bs-r-c), var(--bs-b-c), var(--bs-l-c),
                var(--bs-t-b), var(--bs-r-b), var(--bs-b-b), var(--bs-l-b);
                
            /* Corners */
            background-image: var(--c-tl), var(--c-tr), var(--c-bl), var(--c-br);
            background-position: top left, top right, bottom left, bottom right;
            background-size: 8px 8px;
            background-repeat: no-repeat;
        }

        /* HIDE the default Center Dot (::after) on colored cells */
        .cell.green::after, .cell.blue::after, .cell.red::after, .cell.purple::after {
            display: none;
        }

        /* SHOW the Lock Icon (::after) on Locked/Blocked cells */
        .cell.locked-green::after,
        .cell.locked-blue::after,
        .cell.locked-red::after,
        .cell.locked-purple::after,
        .cell.blocked::after {
            display: block !important;
            z-index: 10;
        }

        /* Dynamic border application using variables */
        /* Note: We use inset shadows. Color (2px) is drawn ON TOP of Black (5px). 
           So visible black is 3px wide starting at 2px offset. */
        .cell.border-top {
            z-index: 10;
            --bs-t-c: inset 0 2px 0 0 var(--border-color);
            --bs-t-b: inset 0 5px 0 0 #000000;
        }
        .cell.border-right {
            z-index: 10;
            --bs-r-c: inset -2px 0 0 0 var(--border-color);
            --bs-r-b: inset -5px 0 0 0 #000000;
        }
        .cell.border-bottom {
            z-index: 10;
            --bs-b-c: inset 0 -2px 0 0 var(--border-color);
            --bs-b-b: inset 0 -5px 0 0 #000000;
        }
        .cell.border-left {
            z-index: 10;
            --bs-l-c: inset 2px 0 0 0 var(--border-color);
            --bs-l-b: inset 5px 0 0 0 #000000;
        }

        /* X pattern texture */
        .cell::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                linear-gradient(45deg, transparent 42%, #1a1a1a 42%, #1a1a1a 46%, transparent 46%, transparent 54%, #1a1a1a 54%, #1a1a1a 58%, transparent 58%),
                linear-gradient(-45deg, transparent 42%, #1a1a1a 42%, #1a1a1a 46%, transparent 46%, transparent 54%, #1a1a1a 54%, #1a1a1a 58%, transparent 58%);
            pointer-events: none;
            mask: radial-gradient(circle at center, transparent 12%, black 12%);
            -webkit-mask: radial-gradient(circle at center, transparent 12%, black 12%);
            z-index: 0;
        }

        /* Center dot */
        .cell::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: #1a1a1a;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 0;
        }

        .cell:hover {
            background: #151515;
            border-color: #2a2a2a;
        }

        .cell:hover::before {
            background:
                linear-gradient(45deg, transparent 42%, #222 42%, #222 46%, transparent 46%, transparent 54%, #222 54%, #222 58%, transparent 58%),
                linear-gradient(-45deg, transparent 42%, #222 42%, #222 46%, transparent 46%, transparent 54%, #222 54%, #222 58%, transparent 58%);
        }

        .cell:hover::after {
            background: #222;
        }

        .cell.blocked {
            background: #1a1a1a;
            cursor: not-allowed;
            border-color: #222;
        }

        .cell.blocked::before {
            display: none;
        }

        .cell.blocked::after {
            width: 28px;
            height: 28px;
            background: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23333'%3E%3Cpath d='M12 1C8.676 1 6 3.676 6 7v2H4v14h16V9h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4zm-6 8h12v10H6V11z'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
        }

        /* Color Themes */
        .cell.green {
            --bg-color: #1a5c1a;
            --bg-alt: #0d3d0d;
            --border-color: #39ff14;
            --grid-line: 0 0 0 0 transparent; /* Hide grid line */
            border-color: transparent; /* Hide default grid border */
            z-index: 5;
        }
        .cell.blue {
            --bg-color: #0066a0;
            --bg-alt: #003d60;
            --border-color: #00bfff;
            --grid-line: 0 0 0 0 transparent;
            border-color: transparent;
            z-index: 5;
        }
        .cell.red {
            --bg-color: #8b1a1a;
            --bg-alt: #4d0f0f;
            --border-color: #ff3939;
            --grid-line: 0 0 0 0 transparent;
            border-color: transparent;
            z-index: 5;
        }
        .cell.purple {
            --bg-color: #5c1a8b;
            --bg-alt: #300d47;
            --border-color: #bf39ff;
            --grid-line: 0 0 0 0 transparent;
            border-color: transparent;
            z-index: 5;
        }
        
        /* Apply alternate shade if present */
        .cell.shade-alt {
            background: var(--bg-alt, var(--bg-color));
        }



        /* Hide pattern for colored cells */
        .cell.green::before,
        .cell.blue::before,
        .cell.red::before,
        .cell.purple::before {
            display: none;
        }

        /* Locked cells */
        .cell.locked-green {
            background: #1a5c1a;
            border: 2px dashed #39ff14;
            box-shadow: inset 0 0 15px rgba(57, 255, 20, 0.2);
        }

        .cell.locked-blue {
            background: #0066a0;
            border: 2px dashed #00bfff;
            box-shadow: inset 0 0 15px rgba(0, 191, 255, 0.2);
        }

        .cell.locked-green::before,
        .cell.locked-blue::before,
        .cell.locked-red::before,
        .cell.locked-purple::before {
            display: none;
        }

        .cell.locked-green::after,
        .cell.locked-blue::after,
        .cell.locked-red::after,
        .cell.locked-purple::after {
            width: 16px;
            height: 16px;
            background: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='rgba(255,255,255,0.3)'%3E%3Cpath d='M12 1C8.676 1 6 3.676 6 7v2H4v14h16V9h-2V7c0-3.324-2.676-6-6-6zm0 2c2.276 0 4 1.724 4 4v2H8V7c0-2.276 1.724-4 4-4z'/%3E%3C/svg%3E");
            background-size: contain;
            background-repeat: no-repeat;
        }

        .cell.locked-red {
            background: #8b1a1a;
            border: 2px dashed #ff3939;
            box-shadow: inset 0 0 15px rgba(255, 57, 57, 0.2);
        }

        .cell.locked-purple {
            background: #5c1a8b;
            border: 2px dashed #bf39ff;
            box-shadow: inset 0 0 15px rgba(191, 57, 255, 0.2);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 25px;
            justify-content: center;
        }

        /* Status Panel */
        .status-panel {
            margin-top: 20px;
            padding: 12px 20px;
            background: #0f0f0f;
            border-radius: 2px;
            text-align: center;
            font-size: 0.85rem;
            color: #555;
            border: 1px solid #1a1a1a;
        }

        .status-panel.success {
            background: #0a1a0a;
            color: #39ff14;
            border-color: #1a3a1a;
        }

        .status-panel.error {
            background: #1a0a0a;
            color: #f87171;
            border-color: #3a1a1a;
        }

        .status-panel.solving {
            background: #1a1a0a;
            color: #fbbf24;
            border-color: #3a3a1a;
        }

        /* Solutions Gallery */
        .solutions-section {
            margin-top: 25px;
            padding: 16px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #151515;
            display: none;
        }

        .solutions-section.visible {
            display: block;
        }

        .solutions-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .solution-thumbnail {
            padding: 6px;
            background: #111;
            border-radius: 2px;
            border: 2px solid #222;
            cursor: pointer;
            transition: all 0.2s;
        }

        .solution-thumbnail:hover {
            border-color: #444;
            background: #161616;
        }

        .solution-thumbnail.selected {
            border-color: #39ff14;
        }

        .solution-mini-grid {
            display: grid;
            gap: 0;
        }

        .solution-mini-cell {
            width: 8px;
            height: 8px;
            background: #222;
            border-radius: 0;
        }

        .solution-mini-cell.green {
            background: #39ff14;
        }

        .solution-mini-cell.blue {
            background: #00bfff;
        }

        .solution-mini-cell.red {
            background: #ff3939;
        }

        .solution-mini-cell.purple {
            background: #bf39ff;
        }

        .solution-mini-cell.blocked {
            background: #2a2a2a;
        }


        /* Instructions */
        .instructions {
            margin-top: 30px;
            padding: 16px;
            background: #0a0a0a;
            border-radius: 2px;
            border: 1px solid #151515;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .instructions h3 {
            font-size: 0.8rem;
            margin-bottom: 16px;
            color: #444;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .instructions ul {
            list-style: none;
            font-size: 0.85rem;
            color: #555;
            line-height: 2;
        }

        .instructions li {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .instructions li::before {
            content: 'â€”';
            color: #333;
            flex-shrink: 0;
        }

        /* Cell mode selector */
        .cell-mode-selector {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: #111;
            border-radius: 2px;
            border: 1px solid #222;
        }

        .cell-mode-label {
            font-size: 0.75rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 4px;
        }

        .cell-mode-btn {
            padding: 5px 10px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 2px;
            color: #666;
            cursor: pointer;
            transition: all 0.15s;
        }

        .cell-mode-btn:hover {
            background: #252525;
            color: #888;
        }

        .cell-mode-btn.active {
            background: #252525;
            color: #ccc;
            border-color: #444;
        }

        .cell-mode-btn.green.active {
            background: #1a3a1a;
            color: #39ff14;
            border-color: #2d5a2d;
        }

        .cell-mode-btn.blue.active {
            background: #1a2a4a;
            color: #00bfff;
            border-color: #2d4a7a;
        }

        .cell-mode-btn.red.active {
            background: #3a1a1a;
            color: #ff3939;
            border-color: #5a2d2d;
        }

        .cell-mode-btn.purple.active {
            background: #2a1a3a;
            color: #bf39ff;
            border-color: #4a2d5a;
        }

        /* Fit All Pieces checkbox */
        .fit-mode-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .fit-mode-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 14px;
            background: #111;
            border-radius: 2px;
            border: 1px solid #222;
            transition: all 0.2s;
        }

        .fit-mode-checkbox:hover {
            background: #161616;
            border-color: #333;
        }

        .fit-mode-checkbox.active {
            background: #1a2a1a;
            border-color: #2d5a2d;
        }

        .fit-mode-checkbox input {
            display: none;
        }

        .fit-mode-checkbox .checkbox-box {
            width: 18px;
            height: 18px;
            border: 2px solid #444;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .fit-mode-checkbox.active .checkbox-box {
            background: #39ff14;
            border-color: #39ff14;
        }

        .fit-mode-checkbox .checkbox-box svg {
            width: 12px;
            height: 12px;
            fill: #000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .fit-mode-checkbox.active .checkbox-box svg {
            opacity: 1;
        }

        .fit-mode-checkbox .checkbox-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: color 0.2s;
        }

        .fit-mode-checkbox.active .checkbox-label {
            color: #39ff14;
        }

        /* Fix: Strategic Z-Index Layering */
        /* "Future" borders (Right/Bottom) must be higher than "Past" borders 
           to prevent the next cell in the DOM from covering the previous cell's border. */
        
        /* Tier 1: Top/Left borders (Safe, naturally above previous neighbors) */
        .cell.border-top,
        .cell.border-left {
            z-index: 50 !important;
        }

        /* Tier 2: Bottom borders (Must be above the neighbor below) */
        .cell.border-bottom {
            z-index: 60 !important;
        }

        /* Tier 3: Right borders (Must be above the neighbor to the right) */
        .cell.border-right {
            z-index: 70 !important;
        }
        
        /* Tier 4: Corner case - Right + Bottom combined */
        .cell.border-right.border-bottom {
            z-index: 80 !important;
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>
    <div class="container">
        <h1>Originium Circuitry Solver</h1>

        <!-- Mode Toggle -->
        <div class="mode-toggle-container">
            <div class="mode-toggle">
                <button class="mode-toggle-btn active" id="solverModeBtn" onclick="setMode('solver')">Solver</button>
                <button class="mode-toggle-btn" id="puzzleModeBtn" onclick="setMode('puzzle')">Puzzle</button>
            </div>
        </div>

        <!-- Solver Mode UI -->
        <div id="solverUI">

        <!-- Configuration Panel -->
        <div class="config-panel">
            <div class="config-group">
                <label>Rows</label>
                <input type="number" id="rowCount" min="2" max="10" value="5">
            </div>
            <div class="config-group">
                <label>Cols</label>
                <input type="number" id="colCount" min="2" max="10" value="5">
            </div>
            <button class="btn btn-primary" onclick="generateGrid()">Generate</button>

            <div class="cell-mode-selector">
                <span class="cell-mode-label">Place:</span>
                <button class="cell-mode-btn active" data-mode="none" onclick="setCellMode('none')">None</button>
                <button class="cell-mode-btn" data-mode="blocked" onclick="setCellMode('blocked')">Block</button>
                <button class="cell-mode-btn green" data-mode="locked-green" onclick="setCellMode('locked-green')">Green</button>
                <button class="cell-mode-btn blue" data-mode="locked-blue" onclick="setCellMode('locked-blue')">Blue</button>
            </div>

        </div>

        <!-- Puzzle Area -->
        <div class="puzzle-area">
            <!-- Shape Selector -->
            <div class="shape-selector" id="shapeSelector">
                <div class="shape-selector-title">Shapes</div>
                <div class="shape-selector-grid" id="shapeGrid"></div>
                <button class="hide-blue-btn" id="hideBlueBtn" onclick="toggleHideBlue()">Hide Blue</button>
            </div>

            <div class="puzzle-wrapper">
                <!-- Column Requirements - above the grid -->
                <div class="col-requirements" id="colRequirementsWrapper">
                    <div class="col-req-spacer" id="colReqSpacer"></div>
                    <div class="col-requirements-inner" id="colRequirements" style="display:flex; gap:0;"></div>
                </div>

                <!-- Row with row requirements + grid -->
                <div class="grid-row">
                    <!-- Row Requirements - left of the grid -->
                    <div class="row-requirements" id="rowRequirements"></div>

                    <!-- Main Grid -->
                    <div class="grid" id="grid"></div>
                </div>

                <!-- Action Buttons -->
                <div class="action-buttons">
                    <button class="btn btn-solve" onclick="solvePuzzle()">Solve</button>
                    <button class="btn btn-clear" onclick="clearGrid()">Clear</button>
                </div>

                <!-- Fit All Pieces Mode -->
                <div class="fit-mode-container">
                    <label class="fit-mode-checkbox" id="fitModeCheckbox" onclick="toggleFitMode()">
                        <div class="checkbox-box">
                            <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                        </div>
                        <span class="checkbox-label">Only Required To Fit All Pieces</span>
                    </label>
                </div>

                <!-- Input Mode Toggle -->
                <div class="input-mode-slider">
                    <div class="slider-toggle" onclick="toggleInputMode()">
                        <div class="slider-bg" id="sliderBg"></div>
                        <div class="slider-option" id="optionGrid" data-mode="bar">Grid</div>
                        <div class="slider-option" id="optionNumber" data-mode="stepper">Number</div>
                    </div>
                </div>

                <!-- Status Panel -->
                <div class="status-panel" id="statusPanel">
                    Set requirements for each row and column, then solve
                </div>
            </div>
        </div>

        <!-- Solutions Gallery -->
        <div class="solutions-section" id="solutionsSection">
            <h2>Solutions Found</h2>
            <div class="solutions-gallery" id="solutionsGallery"></div>
        </div>


        <!-- Instructions -->
        <div class="instructions">
            <h3>Instructions</h3>
            <ul>
                <li>Set grid dimensions and click Generate</li>
                <li>Use the arrows to set required green/blue cell counts per row/column</li>
                <li>Toggle "Block cells" mode and click cells to mark them as blocked</li>
                <li>Click Solve to find valid configurations using the defined shapes</li>
            </ul>
        </div>

        </div><!-- End Solver UI -->

        <!-- Puzzle Mode UI -->
        <div id="puzzleUI" style="display: none;">
            <div class="puzzle-config-panel">
                <h2>Puzzle Configuration</h2>

                <div class="puzzle-difficulty-selector">
                    <h3>Difficulty</h3>
                    <div class="difficulty-buttons">
                        <button class="difficulty-btn" data-difficulty="easy" onclick="setDifficulty('easy')">Easy</button>
                        <button class="difficulty-btn active" data-difficulty="medium" onclick="setDifficulty('medium')">Medium</button>
                        <button class="difficulty-btn" data-difficulty="hard" onclick="setDifficulty('hard')">Hard</button>
                        <button class="difficulty-btn" data-difficulty="expert" onclick="setDifficulty('expert')">Expert</button>
                        <button class="difficulty-btn" data-difficulty="master" onclick="setDifficulty('master')">Master</button>
                    </div>
                </div>

                <div class="puzzle-custom-config">
                    <h3>Custom Settings</h3>
                    <div class="custom-config-grid">
                        <div class="config-item">
                            <label>Grid Size</label>
                            <div class="size-inputs">
                                <input type="number" id="puzzleRows" min="4" max="10" value="5">
                                <span>x</span>
                                <input type="number" id="puzzleCols" min="4" max="10" value="5">
                            </div>
                        </div>
                        <div class="config-item">
                            <label>Colors</label>
                            <div class="color-toggles">
                                <label class="color-toggle green active"><input type="checkbox" checked onchange="togglePuzzleColor('green')"> Green</label>
                                <label class="color-toggle blue active"><input type="checkbox" checked onchange="togglePuzzleColor('blue')"> Blue</label>
                                <label class="color-toggle red"><input type="checkbox" onchange="togglePuzzleColor('red')"> Red</label>
                                <label class="color-toggle purple"><input type="checkbox" onchange="togglePuzzleColor('purple')"> Purple</label>
                            </div>
                        </div>
                        <div class="config-item">
                            <label>Features</label>
                            <div class="feature-toggles">
                                <label class="feature-toggle"><input type="checkbox" id="enableBlockers" checked> Blockers</label>
                                <label class="feature-toggle"><input type="checkbox" id="enableLocks"> Locked Cells</label>
                            </div>
                        </div>
                    </div>
                </div>

                <button class="btn btn-generate-puzzle" id="generatePuzzleBtn" onclick="generatePuzzle()">Generate Puzzle</button>
            </div>

            <div class="puzzle-play-area" id="puzzlePlayArea" style="display: none;">
                <!-- Puzzle grid and shape palette will be rendered here -->
            </div>
        </div><!-- End Puzzle UI -->

    </div>

    <script src="shapes.js"></script>
    <script src="solver.js"></script>
    <script src="puzzle-generator.js"></script>
    <script>
        // SVG icons
        const upArrow = `<svg viewBox="0 0 24 24"><path d="M7 14l5-5 5 5z"/></svg>`;
        const downArrow = `<svg viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/></svg>`;

        let currentMode = 'solver'; // 'solver' or 'puzzle'
        let cellMode = 'none'; // 'none', 'blocked', 'locked-green', 'locked-blue', 'locked-red', 'locked-purple'

        // Toast notification system
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        let barInputMode = true; // Default to bar/grid mode
        let gridState = [];
        let requirements = { rows: [], cols: [] };
        let rows = 5;
        let cols = 5;
        let shapeCounts = new Map(); // Track shape ID -> count for solving
        let fitAllPiecesMode = false; // When true, ignore requirements, just fit all pieces
        let hideBlue = false; // When true, hide blue inputs and center green
        let enabledColors = ['green', 'blue']; // Colors enabled for current puzzle
        const ALL_COLORS = ['green', 'blue', 'red', 'purple'];

        function setMode(mode) {
            currentMode = mode;
            document.getElementById('solverModeBtn').classList.toggle('active', mode === 'solver');
            document.getElementById('puzzleModeBtn').classList.toggle('active', mode === 'puzzle');

            // Show/hide mode-specific UI
            document.getElementById('solverUI').style.display = mode === 'solver' ? 'block' : 'none';
            document.getElementById('puzzleUI').style.display = mode === 'puzzle' ? 'block' : 'none';

            if (mode === 'puzzle') {
                initPuzzleMode();
            }
        }

        function setCellMode(mode) {
            cellMode = mode;
            document.querySelectorAll('.cell-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
        }

        function toggleFitMode() {
            fitAllPiecesMode = !fitAllPiecesMode;
            const checkbox = document.getElementById('fitModeCheckbox');
            checkbox.classList.toggle('active', fitAllPiecesMode);
        }

        function toggleHideBlue() {
            hideBlue = !hideBlue;
            const btn = document.getElementById('hideBlueBtn');
            btn.classList.toggle('active', hideBlue);
            btn.textContent = hideBlue ? 'Show Blue' : 'Hide Blue';
            regenerateInputs();
        }

        function toggleInputMode() {
            barInputMode = !barInputMode;
            updateSliderToggle();
            regenerateInputs();
        }

        function updateSliderToggle() {
            const gridOption = document.getElementById('optionGrid');
            const numberOption = document.getElementById('optionNumber');
            const sliderBg = document.getElementById('sliderBg');

            if (barInputMode) {
                gridOption.classList.add('active');
                numberOption.classList.remove('active');
                sliderBg.style.width = gridOption.offsetWidth + 'px';
                sliderBg.style.left = '4px';
            } else {
                gridOption.classList.remove('active');
                numberOption.classList.add('active');
                sliderBg.style.width = numberOption.offsetWidth + 'px';
                sliderBg.style.left = (gridOption.offsetWidth + 4) + 'px';
            }
        }

        function regenerateInputs() {
            // Regenerate column requirements (green left, blue right)
            const colReqs = document.getElementById('colRequirements');
            colReqs.innerHTML = '';
            for (let c = 0; c < cols; c++) {
                const colReq = document.createElement('div');
                colReq.className = 'col-req';
                if (barInputMode) {
                    colReq.appendChild(createBarInput('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createBarInput('blue', 'col', c, rows));
                    }
                } else {
                    colReq.appendChild(createStepper('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createStepper('blue', 'col', c, rows));
                    }
                }
                colReqs.appendChild(colReq);
            }

            // Regenerate row requirements (blue on top, green on bottom)
            const rowReqs = document.getElementById('rowRequirements');
            rowReqs.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                const rowReq = document.createElement('div');
                rowReq.className = 'row-req';
                if (barInputMode) {
                    if (!hideBlue) {
                        rowReq.appendChild(createBarInput('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createBarInput('green', 'row', r, cols));
                } else {
                    if (!hideBlue) {
                        rowReq.appendChild(createStepper('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createStepper('green', 'row', r, cols));
                }
                rowReqs.appendChild(rowReq);
            }

            // Update spacer to match row requirements width
            const spacer = document.getElementById('colReqSpacer');
            spacer.style.width = '60px';
        }

        function createBarInput(color, type, index, max) {
            const container = document.createElement('div');
            container.className = `bar-input ${color}`;
            container.dataset.type = type;
            container.dataset.index = index;
            container.dataset.color = color;
            container.dataset.max = max;
            container.dataset.value = requirements[type === 'col' ? 'cols' : 'rows'][index]?.[color] || 0;

            for (let i = 1; i <= max; i++) {
                const segment = document.createElement('div');
                segment.className = 'bar-segment';
                segment.dataset.level = i;

                if (type === 'col') {
                    // Column inputs: vertical bars, segments stack vertically
                    const segmentHeight = Math.floor((60 - (max - 1) * 1) / max);
                    segment.style.height = segmentHeight + 'px';
                    segment.style.width = '100%';
                } else {
                    // Row inputs: horizontal bars, segments stack horizontally
                    const segmentWidth = Math.floor((60 - (max - 1) * 1) / max);
                    segment.style.width = segmentWidth + 'px';
                    segment.style.height = '100%';
                }

                const currentValue = parseInt(container.dataset.value) || 0;
                if (i <= currentValue) {
                    segment.classList.add('filled');
                }

                segment.onclick = (e) => {
                    e.stopPropagation();
                    handleBarClick(container, i);
                };

                container.appendChild(segment);
            }

            return container;
        }

        function handleBarClick(container, level) {
            const type = container.dataset.type;
            const index = parseInt(container.dataset.index);
            const color = container.dataset.color;
            const currentValue = parseInt(container.dataset.value) || 0;

            // If clicking the same level that's already set, clear it (set to level - 1)
            // Otherwise set to clicked level
            let newValue;
            if (currentValue === level) {
                newValue = level - 1;
            } else {
                newValue = level;
            }

            container.dataset.value = newValue;

            // Update visual state
            const segments = container.querySelectorAll('.bar-segment');
            segments.forEach(seg => {
                const segLevel = parseInt(seg.dataset.level);
                seg.classList.toggle('filled', segLevel <= newValue);
            });

            // Update requirements
            if (type === 'col') {
                requirements.cols[index][color] = newValue;
            } else {
                requirements.rows[index][color] = newValue;
            }
        }

        function createStepper(color, type, index, max) {
            const stepper = document.createElement('div');
            stepper.className = `stepper ${color}`;
            stepper.dataset.type = type;
            stepper.dataset.index = index;
            stepper.dataset.color = color;

            const upBtn = document.createElement('div');
            upBtn.className = 'stepper-btn up';
            upBtn.innerHTML = upArrow;
            upBtn.onclick = (e) => {
                e.stopPropagation();
                adjustValue(stepper, 1, max);
            };

            const valueDisplay = document.createElement('div');
            valueDisplay.className = 'stepper-value';
            valueDisplay.textContent = '0';

            const downBtn = document.createElement('div');
            downBtn.className = 'stepper-btn down';
            downBtn.innerHTML = downArrow;
            downBtn.onclick = (e) => {
                e.stopPropagation();
                adjustValue(stepper, -1, max);
            };

            stepper.appendChild(upBtn);
            stepper.appendChild(valueDisplay);
            stepper.appendChild(downBtn);

            return stepper;
        }

        function adjustValue(stepper, delta, max) {
            const valueEl = stepper.querySelector('.stepper-value');
            let val = parseInt(valueEl.textContent) || 0;
            val = Math.max(0, Math.min(max, val + delta));
            valueEl.textContent = val;

            const type = stepper.dataset.type;
            const index = parseInt(stepper.dataset.index);
            const color = stepper.dataset.color;

            if (type === 'col') {
                requirements.cols[index][color] = val;
            } else {
                requirements.rows[index][color] = val;
            }
        }

        function generateGrid() {
            rows = parseInt(document.getElementById('rowCount').value) || 5;
            cols = parseInt(document.getElementById('colCount').value) || 5;
            rows = Math.max(2, Math.min(10, rows));
            cols = Math.max(2, Math.min(10, cols));

            gridState = Array(rows).fill(null).map(() => Array(cols).fill('empty'));
            requirements = {
                rows: Array(rows).fill(null).map(() => ({ green: 0, blue: 0 })),
                cols: Array(cols).fill(null).map(() => ({ green: 0, blue: 0 }))
            };

            const grid = document.getElementById('grid');
            grid.style.gridTemplateColumns = `repeat(${cols}, 68px)`;
            grid.innerHTML = '';

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.onclick = () => handleCellClick(r, c, cell);
                    grid.appendChild(cell);
                }
            }

            // Column requirements (green left, blue right)
            const colReqs = document.getElementById('colRequirements');
            colReqs.innerHTML = '';
            for (let c = 0; c < cols; c++) {
                const colReq = document.createElement('div');
                colReq.className = 'col-req';
                if (barInputMode) {
                    colReq.appendChild(createBarInput('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createBarInput('blue', 'col', c, rows));
                    }
                } else {
                    colReq.appendChild(createStepper('green', 'col', c, rows));
                    if (!hideBlue) {
                        colReq.appendChild(createStepper('blue', 'col', c, rows));
                    }
                }
                colReqs.appendChild(colReq);
            }

            const spacer = document.getElementById('colReqSpacer');
            spacer.style.width = '60px';

            // Row requirements (blue on top, green on bottom)
            const rowReqs = document.getElementById('rowRequirements');
            rowReqs.innerHTML = '';
            for (let r = 0; r < rows; r++) {
                const rowReq = document.createElement('div');
                rowReq.className = 'row-req';
                if (barInputMode) {
                    if (!hideBlue) {
                        rowReq.appendChild(createBarInput('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createBarInput('green', 'row', r, cols));
                } else {
                    if (!hideBlue) {
                        rowReq.appendChild(createStepper('blue', 'row', r, cols));
                    }
                    rowReq.appendChild(createStepper('green', 'row', r, cols));
                }
                rowReqs.appendChild(rowReq);
            }

            // Hide solutions
            document.getElementById('solutionsSection').classList.remove('visible');

            updateStatus('Ready');
        }

        function handleCellClick(r, c, cellElement) {
            if (cellMode === 'none') return;

            const current = gridState[r][c];

            // Toggle: if clicking same type, clear it; otherwise set to new type
            if (current === cellMode) {
                gridState[r][c] = 'empty';
            } else {
                gridState[r][c] = cellMode;
            }

            updateCellDisplay(cellElement, gridState[r][c]);
        }

        function updateCellDisplay(cell, state) {
            // Preserve only base 'cell' class, remove all state classes
            cell.className = 'cell';
            if (state && state !== 'empty') {
                cell.classList.add(state);
            }
        }

        function clearGrid() {
            gridState = Array(rows).fill(null).map(() => Array(cols).fill('empty'));
            document.querySelectorAll('#grid .cell').forEach(cell => {
                cell.className = 'cell';
            });

            // Reset requirements
            requirements = {
                rows: Array(rows).fill(null).map(() => ({ green: 0, blue: 0 })),
                cols: Array(cols).fill(null).map(() => ({ green: 0, blue: 0 }))
            };

            // Clear shape selections
            shapeCounts.clear();
            document.querySelectorAll('.shape-selector-item').forEach(item => {
                item.classList.remove('active');
                const badge = item.querySelector('.shape-count-badge');
                if (badge) badge.textContent = '1';
            });

            // Regenerate inputs to reset their visual state
            regenerateInputs();

            currentSolutions = [];
            selectedSolutionIndex = -1;
            document.getElementById('solutionsSection').classList.remove('visible');
            updateStatus('Grid cleared');
        }

        function clearSolutionOnly() {
            // Clear just the solution display, keeping locked/blocked cells
            document.querySelectorAll('#grid .cell').forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                updateCellDisplay(cell, gridState[r][c]);
            });
            currentSolutions = [];
            selectedSolutionIndex = -1;
            document.getElementById('solutionsSection').classList.remove('visible');
            updateStatus('Ready');
        }

        let currentSolutions = [];
        let selectedSolutionIndex = -1;

        function solvePuzzle() {
            if (shapeCounts.size === 0) {
                updateStatus('Please select at least one shape from the left panel', 'error');
                return;
            }

            updateStatus('Solving...', 'solving');

            // Get blocked cells
            const blockedCells = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (gridState[r][c] === 'blocked' || gridState[r][c] === 'locked-green' || gridState[r][c] === 'locked-blue') {
                        blockedCells.push([r, c]);
                    }
                }
            }

            // Convert shapeCounts map to object
            const shapeCountsObj = Object.fromEntries(shapeCounts);

            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                try {
                    let result;

                    if (fitAllPiecesMode) {
                        // Just fit all pieces, ignore row/column requirements
                        result = runFitAllPiecesSolver(rows, cols, blockedCells, shapeCountsObj);
                    } else {
                        // Calculate locked cell contributions and adjusted requirements
                        const lockedGreenCounts = { rows: Array(rows).fill(0), cols: Array(cols).fill(0) };
                        const lockedBlueCounts = { rows: Array(rows).fill(0), cols: Array(cols).fill(0) };

                        for (let r = 0; r < rows; r++) {
                            for (let c = 0; c < cols; c++) {
                                if (gridState[r][c] === 'locked-green') {
                                    lockedGreenCounts.rows[r]++;
                                    lockedGreenCounts.cols[c]++;
                                } else if (gridState[r][c] === 'locked-blue') {
                                    lockedBlueCounts.rows[r]++;
                                    lockedBlueCounts.cols[c]++;
                                }
                            }
                        }

                        // Create adjusted requirements (subtract locked cell contributions)
                        const adjustedRowReqs = requirements.rows.map((req, r) => ({
                            green: Math.max(0, req.green - lockedGreenCounts.rows[r]),
                            blue: Math.max(0, req.blue - lockedBlueCounts.rows[r])
                        }));
                        const adjustedColReqs = requirements.cols.map((req, c) => ({
                            green: Math.max(0, req.green - lockedGreenCounts.cols[c]),
                            blue: Math.max(0, req.blue - lockedBlueCounts.cols[c])
                        }));

                        // Check for over-constrained (locked cells exceed requirements)
                        let overConstrained = false;
                        for (let r = 0; r < rows; r++) {
                            if (lockedGreenCounts.rows[r] > requirements.rows[r].green) {
                                updateStatus(`Row ${r + 1}: locked green cells exceed requirement`, 'error');
                                overConstrained = true;
                                break;
                            }
                            if (lockedBlueCounts.rows[r] > requirements.rows[r].blue) {
                                updateStatus(`Row ${r + 1}: locked blue cells exceed requirement`, 'error');
                                overConstrained = true;
                                break;
                            }
                        }
                        if (!overConstrained) {
                            for (let c = 0; c < cols; c++) {
                                if (lockedGreenCounts.cols[c] > requirements.cols[c].green) {
                                    updateStatus(`Column ${c + 1}: locked green cells exceed requirement`, 'error');
                                    overConstrained = true;
                                    break;
                                }
                                if (lockedBlueCounts.cols[c] > requirements.cols[c].blue) {
                                    updateStatus(`Column ${c + 1}: locked blue cells exceed requirement`, 'error');
                                    overConstrained = true;
                                    break;
                                }
                            }
                        }
                        if (overConstrained) return;

                        // Create modified grid state where locked cells are treated as blocked
                        const modifiedGridState = gridState.map(row => row.map(cell => {
                            if (cell === 'locked-green' || cell === 'locked-blue') {
                                return 'blocked';
                            }
                            return cell;
                        }));

                        result = runSolverWithShapeCounts(
                            rows, cols, modifiedGridState, adjustedRowReqs, adjustedColReqs, shapeCountsObj
                        );

                        // Check if adjusted requirements are all zero (solved by locked cells alone)
                        if (!result.success) {
                            const allZero = adjustedRowReqs.every(r => r.green === 0 && r.blue === 0) &&
                                           adjustedColReqs.every(c => c.green === 0 && c.blue === 0);
                            if (allZero) {
                                result = {
                                    success: true,
                                    solutions: [{ green: [], blue: [], greenPlacements: [], bluePlacements: [] }]
                                };
                                updateStatus('Solved by locked cells alone', 'success');
                            }
                        }
                    }

                    if (result.success) {
                        currentSolutions = result.solutions;
                        updateStatus(`Found ${result.solutions.length} solution${result.solutions.length > 1 ? 's' : ''}`, 'success');
                        displaySolutions(result.solutions);

                        // Auto-apply first solution
                        if (result.solutions.length > 0) {
                            applySolution(0);
                        }
                    } else {
                        currentSolutions = [];
                        updateStatus(result.message, 'error');
                        document.getElementById('solutionsSection').classList.remove('visible');
                    }
                } catch (e) {
                    console.error('Solver error:', e);
                    updateStatus('Solver error: ' + e.message, 'error');
                }
            }, 50);
        }

        function displaySolutions(solutions) {
            const section = document.getElementById('solutionsSection');
            const gallery = document.getElementById('solutionsGallery');
            gallery.innerHTML = '';

            solutions.forEach((solution, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'solution-thumbnail';
                thumb.dataset.index = index;
                thumb.onclick = () => applySolution(index);

                const miniGrid = document.createElement('div');
                miniGrid.className = 'solution-mini-grid';
                miniGrid.style.gridTemplateColumns = `repeat(${cols}, 8px)`;

                // Create cell lookup sets
                const greenSet = new Set(solution.green.map(([r, c]) => `${r},${c}`));
                const blueSet = new Set(solution.blue.map(([r, c]) => `${r},${c}`));

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'solution-mini-cell';

                        const key = `${r},${c}`;
                        const cellState = gridState[r][c];

                        if (cellState === 'blocked') {
                            cell.classList.add('blocked');
                        } else if (cellState === 'locked-green' || greenSet.has(key)) {
                            cell.classList.add('green');
                        } else if (cellState === 'locked-blue' || blueSet.has(key)) {
                            cell.classList.add('blue');
                        }

                        miniGrid.appendChild(cell);
                    }
                }

                thumb.appendChild(miniGrid);
                gallery.appendChild(thumb);
            });

            section.classList.add('visible');
        }

        function applySolution(index) {
            selectedSolutionIndex = index;
            const solution = currentSolutions[index];

            // Update thumbnail selection
            document.querySelectorAll('.solution-thumbnail').forEach((thumb, i) => {
                thumb.classList.toggle('selected', i === index);
            });

            // Build maps for cell -> shape membership and neighbors
            const cellShapeMap = new Map(); // key -> { color, shapeIndex, cells }

            // Process green placements
            if (solution.greenPlacements) {
                solution.greenPlacements.forEach((placement, shapeIdx) => {
                    const cellSet = new Set(placement.cells.map(([r, c]) => `${r},${c}`));
                    placement.cells.forEach(([r, c], cellIdx) => {
                        cellShapeMap.set(`${r},${c}`, {
                            color: 'green',
                            shapeIndex: shapeIdx,
                            cellIndex: cellIdx,
                            cellSet: cellSet
                        });
                    });
                });
            }

            // Process blue placements
            if (solution.bluePlacements) {
                solution.bluePlacements.forEach((placement, shapeIdx) => {
                    const cellSet = new Set(placement.cells.map(([r, c]) => `${r},${c}`));
                    placement.cells.forEach(([r, c], cellIdx) => {
                        cellShapeMap.set(`${r},${c}`, {
                            color: 'blue',
                            shapeIndex: shapeIdx,
                            cellIndex: cellIdx,
                            cellSet: cellSet
                        });
                    });
                });
            }

            // Update main grid
            document.querySelectorAll('#grid .cell').forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const key = `${r},${c}`;

                // Reset classes and inline styles
                cell.className = 'cell';

                const cellState = gridState[r][c];

                if (cellState === 'blocked') {
                    cell.classList.add('blocked');
                } else if (cellState === 'locked-green') {
                    cell.classList.add('locked-green');
                } else if (cellState === 'locked-blue') {
                    cell.classList.add('locked-blue');
                } else if (cellShapeMap.has(key)) {
                    const info = cellShapeMap.get(key);
                    cell.classList.add(info.color);

                    // Alternating shade based on checkerboard pattern (row + col parity)
                    if ((r + c) % 2 === 1) {
                        cell.classList.add('shade-alt');
                    }

                    // Check neighbors for border edges
                    const topKey = `${r - 1},${c}`;
                    const rightKey = `${r},${c + 1}`;
                    const bottomKey = `${r + 1},${c}`;
                    const leftKey = `${r},${c - 1}`;

                    const hasTop = !info.cellSet.has(topKey);
                    const hasRight = !info.cellSet.has(rightKey);
                    const hasBottom = !info.cellSet.has(bottomKey);
                    const hasLeft = !info.cellSet.has(leftKey);

                    // Add border if neighbor is not part of same shape
                    if (hasTop) cell.classList.add('border-top');
                    if (hasRight) cell.classList.add('border-right');
                    if (hasBottom) cell.classList.add('border-bottom');
                    if (hasLeft) cell.classList.add('border-left');
                }
            });
        }

        function updateStatus(message, type = '') {
            const panel = document.getElementById('statusPanel');
            panel.textContent = message;
            panel.className = 'status-panel';
            if (type) panel.classList.add(type);
        }

        // Render shape selector (left panel)
        function renderShapeSelector() {
            const grid = document.getElementById('shapeGrid');
            grid.innerHTML = '';

            for (const [id, shape] of Object.entries(SHAPE_LIBRARY)) {
                const item = document.createElement('div');
                item.className = 'shape-selector-item';
                item.dataset.shapeId = id;
                item.title = `${shape.name} (click: +1, shift+click: -1)`;

                const baseShape = shape.rotations[0];
                const bounds = getShapeBounds(baseShape);

                const miniGrid = document.createElement('div');
                miniGrid.className = 'shape-mini-grid';
                miniGrid.style.gridTemplateColumns = `repeat(${bounds.width}, 10px)`;

                const cellSet = new Set(baseShape.map(([r, c]) => `${r},${c}`));

                for (let r = 0; r < bounds.height; r++) {
                    for (let c = 0; c < bounds.width; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'shape-mini-cell';
                        if (cellSet.has(`${r},${c}`)) {
                            cell.classList.add('filled');
                        }
                        miniGrid.appendChild(cell);
                    }
                }

                item.appendChild(miniGrid);

                const badge = document.createElement('div');
                badge.className = 'shape-count-badge';
                badge.textContent = '1';
                item.appendChild(badge);

                item.onclick = (e) => handleShapeClick(id, item, e);
                item.oncontextmenu = (e) => {
                    e.preventDefault();
                    handleShapeClick(id, item, { ...e, button: 2 });
                };

                grid.appendChild(item);
            }
        }

        function handleShapeClick(shapeId, element, event) {
            event.preventDefault();

            const currentCount = shapeCounts.get(shapeId) || 0;
            let newCount;

            if (event.button === 2 || event.shiftKey) {
                // Right-click or shift+click: decrement
                newCount = Math.max(0, currentCount - 1);
            } else {
                // Left-click: increment
                newCount = currentCount + 1;
            }

            if (newCount === 0) {
                shapeCounts.delete(shapeId);
                element.classList.remove('active');
            } else {
                shapeCounts.set(shapeId, newCount);
                element.classList.add('active');
            }

            // Update badge
            const badge = element.querySelector('.shape-count-badge');
            if (badge) {
                badge.textContent = newCount || '';
            }

            console.log('Shape counts:', Object.fromEntries(shapeCounts));
        }

        // Puzzle Mode Functions
        let puzzleConfig = {
            difficulty: 'medium',
            gridRows: 5,
            gridCols: 5,
            colors: ['green', 'blue'],
            blockers: true,
            locks: false
        };

        let currentPuzzle = null;

        function initPuzzleMode() {
            console.log('Puzzle mode initialized');
        }

        function setDifficulty(difficulty) {
            puzzleConfig.difficulty = difficulty;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.difficulty === difficulty);
            });

            // Apply preset values
            const presets = {
                easy: { rows: 4, cols: 4, colors: ['green'], blockers: false, locks: false },
                medium: { rows: 5, cols: 5, colors: ['green', 'blue'], blockers: true, locks: false },
                hard: { rows: 6, cols: 6, colors: ['green', 'blue'], blockers: true, locks: true },
                expert: { rows: 7, cols: 7, colors: ['green', 'blue', 'red'], blockers: true, locks: true },
                master: { rows: 8, cols: 8, colors: ['green', 'blue', 'red', 'purple'], blockers: true, locks: true }
            };

            const preset = presets[difficulty];
            if (preset) {
                document.getElementById('puzzleRows').value = preset.rows;
                document.getElementById('puzzleCols').value = preset.cols;
                document.getElementById('enableBlockers').checked = preset.blockers;
                document.getElementById('enableLocks').checked = preset.locks;

                // Update color toggles
                document.querySelectorAll('.color-toggle').forEach(toggle => {
                    const color = toggle.classList.contains('green') ? 'green' :
                                  toggle.classList.contains('blue') ? 'blue' :
                                  toggle.classList.contains('red') ? 'red' : 'purple';
                    const isEnabled = preset.colors.includes(color);
                    toggle.classList.toggle('active', isEnabled);
                    toggle.querySelector('input').checked = isEnabled;
                });

                puzzleConfig.colors = [...preset.colors];
            }
        }

        function togglePuzzleColor(color) {
            const toggle = document.querySelector(`.color-toggle.${color}`);
            const isActive = toggle.classList.toggle('active');

            if (isActive) {
                if (!puzzleConfig.colors.includes(color)) {
                    puzzleConfig.colors.push(color);
                }
            } else {
                puzzleConfig.colors = puzzleConfig.colors.filter(c => c !== color);
            }

            // Ensure at least one color is selected
            if (puzzleConfig.colors.length === 0) {
                puzzleConfig.colors = ['green'];
                document.querySelector('.color-toggle.green').classList.add('active');
                document.querySelector('.color-toggle.green input').checked = true;
            }
        }

        function generatePuzzle() {
            puzzleConfig.gridRows = parseInt(document.getElementById('puzzleRows').value) || 5;
            puzzleConfig.gridCols = parseInt(document.getElementById('puzzleCols').value) || 5;
            puzzleConfig.blockers = document.getElementById('enableBlockers').checked;
            puzzleConfig.locks = document.getElementById('enableLocks').checked;

            // Get button and show loading state
            const btn = document.getElementById('generatePuzzleBtn');
            const originalText = btn.textContent;
            btn.textContent = 'Generating...';
            btn.disabled = true;

            console.log('Generating puzzle with config:', puzzleConfig);

            // Use setTimeout to allow UI to update before blocking generation
            setTimeout(() => {
                const puzzle = PuzzleGenerator.generate({
                    gridRows: puzzleConfig.gridRows,
                    gridCols: puzzleConfig.gridCols,
                    colors: puzzleConfig.colors,
                    blockers: puzzleConfig.blockers,
                    locks: puzzleConfig.locks
                });

                // Restore button
                btn.textContent = originalText;
                btn.disabled = false;

                if (puzzle) {
                    currentPuzzle = puzzle;
                    renderPuzzlePlayArea(puzzle);
                    showToast('Puzzle generated!', 'success', 2000);
                } else {
                    showToast('Failed to generate puzzle. Try different settings.', 'error', 4000);
                }
            }, 50);
        }

        function renderPuzzlePlayArea(puzzle) {
            const playArea = document.getElementById('puzzlePlayArea');
            playArea.style.display = 'block';
            playArea.innerHTML = '';

            // Create puzzle container
            const container = document.createElement('div');
            container.className = 'puzzle-container';
            container.innerHTML = `
                <div class="puzzle-main">
                    <div class="puzzle-grid-area">
                        <div class="puzzle-col-requirements" id="puzzleColReqs"></div>
                        <div class="puzzle-grid-row">
                            <div class="puzzle-row-requirements" id="puzzleRowReqs"></div>
                            <div class="puzzle-grid" id="puzzleGrid"></div>
                        </div>
                    </div>
                    <div class="puzzle-shape-palette" id="puzzleShapePalette">
                        <h3>Shapes</h3>
                        <div class="palette-shapes" id="paletteShapes"></div>
                    </div>
                </div>
                <div class="puzzle-actions">
                    <button class="btn btn-primary" onclick="resetPuzzle()">Reset</button>
                    <button class="btn btn-primary" onclick="generatePuzzle()">New Puzzle</button>
                    <button class="btn btn-primary" onclick="showOneHint()" title="Show where one piece goes">Hint</button>
                    <button class="btn btn-primary" onclick="showSolution()" title="Show the full solution">Solution</button>
                </div>
            `;
            playArea.appendChild(container);

            // Render components
            renderPuzzleGrid(puzzle);
            renderPuzzleRequirements(puzzle);
            renderPuzzleShapePalette(puzzle);
        }

        function renderPuzzleGrid(puzzle) {
            const grid = document.getElementById('puzzleGrid');
            const cellSize = puzzle.grid.length > 6 ? (puzzle.grid.length > 8 ? 48 : 56) : 68;

            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = `repeat(${puzzle.grid[0].length}, ${cellSize}px)`;
            grid.style.gap = '0';
            grid.innerHTML = '';

            for (let r = 0; r < puzzle.grid.length; r++) {
                for (let c = 0; c < puzzle.grid[0].length; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    const state = puzzle.grid[r][c];

                    // Determine the PLAYABLE state (not the solved state)
                    // The grid contains the solution - we need to show initial puzzle state
                    let playableState = 'empty';

                    // Check if this cell is a blocker
                    const isBlocker = puzzle.blockers && puzzle.blockers.some(
                        ([br, bc]) => br === r && bc === c
                    );

                    // Check if this cell is a lock
                    let lockColor = null;
                    if (puzzle.locks) {
                        for (const [color, positions] of Object.entries(puzzle.locks)) {
                            if (positions.some(([lr, lc]) => lr === r && lc === c)) {
                                lockColor = color;
                                break;
                            }
                        }
                    }

                    if (isBlocker) {
                        cell.classList.add('blocked');
                        playableState = 'blocked';
                    } else if (lockColor) {
                        cell.classList.add(`locked-${lockColor}`);
                        playableState = `locked-${lockColor}`;
                    }

                    // Store states for puzzle
                    cell.dataset.originalState = playableState;
                    cell.dataset.currentState = playableState;

                    // Right-click to remove placed shapes
                    cell.addEventListener('contextmenu', handleCellRightClick);

                    grid.appendChild(cell);
                }
            }
        }

        function renderPuzzleRequirements(puzzle) {
            const colReqs = document.getElementById('puzzleColReqs');
            const rowReqs = document.getElementById('puzzleRowReqs');
            const colors = puzzleConfig.colors;

            // Column requirements
            colReqs.innerHTML = '';
            colReqs.style.display = 'flex';
            colReqs.style.gap = '0';
            colReqs.style.marginLeft = '60px'; // Spacer for row reqs

            for (let c = 0; c < puzzle.requirements.cols.length; c++) {
                const colReq = document.createElement('div');
                colReq.className = 'puzzle-col-req';
                colReq.style.width = (puzzle.grid.length > 6 ? (puzzle.grid.length > 8 ? 48 : 56) : 68) + 'px';
                colReq.style.display = 'flex';
                colReq.style.justifyContent = 'center';
                colReq.style.gap = '1px';

                for (const color of colors) {
                    const count = puzzle.requirements.cols[c][color] || 0;
                    if (count > 0) {
                        const bar = createPrescriptiveBar(color, count, 'col', c);
                        colReq.appendChild(bar);
                    }
                }

                colReqs.appendChild(colReq);
            }

            // Row requirements
            rowReqs.innerHTML = '';
            rowReqs.style.display = 'flex';
            rowReqs.style.flexDirection = 'column';
            rowReqs.style.gap = '0';

            for (let r = 0; r < puzzle.requirements.rows.length; r++) {
                const rowReq = document.createElement('div');
                rowReq.className = 'puzzle-row-req';
                rowReq.style.height = (puzzle.grid.length > 6 ? (puzzle.grid.length > 8 ? 48 : 56) : 68) + 'px';
                rowReq.style.display = 'flex';
                rowReq.style.flexDirection = 'column';
                rowReq.style.justifyContent = 'center';
                rowReq.style.gap = '1px';
                rowReq.style.width = '60px';

                for (const color of colors) {
                    const count = puzzle.requirements.rows[r][color] || 0;
                    if (count > 0) {
                        const bar = createPrescriptiveBar(color, count, 'row', r);
                        rowReq.appendChild(bar);
                    }
                }

                rowReqs.appendChild(rowReq);
            }
        }

        function createPrescriptiveBar(color, totalCount, type, index) {
            const container = document.createElement('div');
            container.className = `prescriptive-bar ${color}`;
            container.dataset.color = color;
            container.dataset.type = type;
            container.dataset.index = index;
            container.dataset.required = totalCount;

            // Max segments based on grid size (for consistent sizing)
            const maxSegments = type === 'col' ? currentPuzzle.grid.length : currentPuzzle.grid[0].length;

            // Calculate current fill from locked cells
            let currentFill = 0;
            if (currentPuzzle) {
                if (type === 'col') {
                    for (let r = 0; r < currentPuzzle.grid.length; r++) {
                        const cell = currentPuzzle.grid[r][index];
                        if (cell === `locked-${color}`) currentFill++;
                    }
                } else {
                    for (let c = 0; c < currentPuzzle.grid[0].length; c++) {
                        const cell = currentPuzzle.grid[index][c];
                        if (cell === `locked-${color}`) currentFill++;
                    }
                }
            }

            container.dataset.filled = currentFill;

            // Fixed bar dimensions based on grid max
            const isRow = type === 'row';
            container.style.display = 'flex';
            container.style.flexDirection = isRow ? 'row-reverse' : 'column-reverse';
            container.style.gap = '1px';

            // Fixed size: calculate segment size based on max, then multiply
            const segmentSize = Math.floor((55 - (maxSegments - 1)) / maxSegments);

            if (isRow) {
                container.style.width = '55px';
                container.style.height = '14px';
            } else {
                container.style.width = '14px';
                container.style.height = '55px';
            }

            // Only render the segments we need (totalCount), but size them consistently
            for (let i = 0; i < totalCount; i++) {
                const segment = document.createElement('div');
                segment.className = 'prescriptive-segment';

                if (isRow) {
                    segment.style.width = segmentSize + 'px';
                    segment.style.height = '100%';
                } else {
                    segment.style.width = '100%';
                    segment.style.height = segmentSize + 'px';
                }

                // Set border color based on color
                const colorMap = {
                    green: '#39ff14',
                    blue: '#00bfff',
                    red: '#ff3939',
                    purple: '#bf39ff'
                };
                const borderColor = colorMap[color] || '#39ff14';
                segment.style.border = `2px solid ${borderColor}`;
                segment.style.borderRadius = '1px';

                if (i < currentFill) {
                    segment.classList.add('filled');
                    segment.style.background = borderColor;
                }

                container.appendChild(segment);
            }

            return container;
        }

        function renderPuzzleShapePalette(puzzle) {
            const palette = document.getElementById('paletteShapes');
            palette.innerHTML = '';

            for (const color of puzzleConfig.colors) {
                const shapes = puzzle.shapes[color] || [];

                for (const shape of shapes) {
                    const shapeEl = document.createElement('div');
                    shapeEl.className = `palette-shape ${color}`;
                    shapeEl.dataset.shapeId = shape.shapeId;
                    shapeEl.dataset.color = color;

                    // IMPORTANT: Randomize the initial display rotation, NOT the solution rotation
                    // This forces the user to potentially rotate shapes to solve
                    const shapeData = SHAPE_LIBRARY[shape.shapeId];
                    const randomDisplayRotation = Math.floor(Math.random() * shapeData.rotations.length);
                    shapeEl.dataset.rotationIndex = randomDisplayRotation;

                    // Store solution data for hints (solution rotation + position)
                    shapeEl.dataset.solutionRotationIndex = shape.rotationIndex;
                    shapeEl.dataset.solutionRow = shape.position[0];
                    shapeEl.dataset.solutionCol = shape.position[1];
                    shapeEl.style.cursor = 'grab';

                    // Render shape preview using the randomized display rotation
                    const rotation = shapeData.rotations[randomDisplayRotation];
                    const bounds = getShapeBounds(rotation);

                    const preview = document.createElement('div');
                    preview.className = 'shape-preview-grid';
                    preview.style.display = 'grid';
                    preview.style.gridTemplateColumns = `repeat(${bounds.width}, 12px)`;
                    preview.style.gap = '1px';

                    const cellSet = new Set(rotation.map(([r, c]) => `${r},${c}`));

                    for (let r = 0; r < bounds.height; r++) {
                        for (let c = 0; c < bounds.width; c++) {
                            const cell = document.createElement('div');
                            cell.style.width = '12px';
                            cell.style.height = '12px';
                            cell.style.borderRadius = '1px';

                            if (cellSet.has(`${r},${c}`)) {
                                cell.style.background = color === 'green' ? '#39ff14' :
                                                        color === 'blue' ? '#00bfff' :
                                                        color === 'red' ? '#ff3939' : '#bf39ff';
                            } else {
                                cell.style.background = '#1a1a1a';
                            }

                            preview.appendChild(cell);
                        }
                    }

                    shapeEl.appendChild(preview);
                    palette.appendChild(shapeEl);

                    // Add drag handlers
                    shapeEl.addEventListener('mousedown', handleShapeMouseDown);
                }
            }
        }

        // Custom drag system state
        let dragState = {
            active: false,
            shapeId: null,
            color: null,
            rotationIndex: 0,
            sourceElement: null,
            ghost: null,
            gridCellSize: 68,
            lastGridCell: null
        };

        function handleShapeMouseDown(e) {
            const shapeEl = e.target.closest('.palette-shape');
            if (!shapeEl || e.button !== 0) return;

            e.preventDefault();

            const shapeId = shapeEl.dataset.shapeId;
            const color = shapeEl.dataset.color;
            const rotationIndex = parseInt(shapeEl.dataset.rotationIndex);

            // Get grid cell size
            const cellSize = currentPuzzle.grid.length > 6 ?
                (currentPuzzle.grid.length > 8 ? 48 : 56) : 68;

            dragState = {
                active: true,
                shapeId,
                color,
                rotationIndex,
                sourceElement: shapeEl,
                ghost: null,
                gridCellSize: cellSize,
                lastGridCell: null
            };

            // Create ghost element
            createDragGhost(e.clientX, e.clientY);

            // Hide source element
            shapeEl.style.opacity = '0.3';

            // Add document-level listeners
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('keydown', handleDragKeyDown);
        }

        function createDragGhost(x, y) {
            if (dragState.ghost) {
                dragState.ghost.remove();
            }

            const shapeData = SHAPE_LIBRARY[dragState.shapeId];
            const rotation = shapeData.rotations[dragState.rotationIndex];
            const bounds = getShapeBounds(rotation);
            const cellSize = dragState.gridCellSize;

            const ghost = document.createElement('div');
            ghost.id = 'drag-ghost';
            ghost.style.cssText = `
                position: fixed;
                pointer-events: none;
                z-index: 10000;
                opacity: 0.8;
                display: grid;
                grid-template-columns: repeat(${bounds.width}, ${cellSize}px);
                grid-template-rows: repeat(${bounds.height}, ${cellSize}px);
                gap: 0;
            `;

            // Build cell set for border checking
            const cellSet = new Set(rotation.map(([r, c]) => `${r},${c}`));

            // Create cells for the shape
            let cellIndex = 0;
            for (let r = 0; r < bounds.height; r++) {
                for (let c = 0; c < bounds.width; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';

                    // Check if this cell is part of the shape
                    const isShapeCell = rotation.some(([sr, sc]) => sr === r && sc === c);

                    if (isShapeCell) {
                        cell.className = `cell ${dragState.color}`;
                        cell.style.boxSizing = 'border-box';

                        // Alternating shade based on checkerboard pattern (relative to shape bounds)
                        if ((r + c) % 2 === 1) {
                            cell.classList.add('shade-alt');
                        }

                        // Check neighbors for border edges
                        const topKey = `${r - 1},${c}`;
                        const rightKey = `${r},${c + 1}`;
                        const bottomKey = `${r + 1},${c}`;
                        const leftKey = `${r},${c - 1}`;
                        
                        // Check diagonals for Inner Corners
                        const tlKey = `${r - 1},${c - 1}`;
                        const trKey = `${r - 1},${c + 1}`;
                        const brKey = `${r + 1},${c + 1}`;
                        const blKey = `${r + 1},${c - 1}`;

                        const hasTop = !cellSet.has(topKey);
                        const hasRight = !cellSet.has(rightKey);
                        const hasBottom = !cellSet.has(bottomKey);
                        const hasLeft = !cellSet.has(leftKey);

                        // Apply Borders
                        if (hasTop) cell.classList.add('border-top');
                        if (hasRight) cell.classList.add('border-right');
                        if (hasBottom) cell.classList.add('border-bottom');
                        if (hasLeft) cell.classList.add('border-left');
                        
                        // Apply Inner Corners (If neighbors exist but diagonal is empty)
                        if (!hasTop && !hasLeft && !cellSet.has(tlKey)) cell.classList.add('corner-tl');
                        if (!hasTop && !hasRight && !cellSet.has(trKey)) cell.classList.add('corner-tr');
                        if (!hasBottom && !hasRight && !cellSet.has(brKey)) cell.classList.add('corner-br');
                        if (!hasBottom && !hasLeft && !cellSet.has(blKey)) cell.classList.add('corner-bl');
                    } else {
                        cell.style.background = 'transparent';
                    }

                    ghost.appendChild(cell);
                }
            }

            // Position centered on cursor
            const ghostWidth = bounds.width * cellSize;
            const ghostHeight = bounds.height * cellSize;
            ghost.style.left = (x - ghostWidth / 2) + 'px';
            ghost.style.top = (y - ghostHeight / 2) + 'px';

            document.body.appendChild(ghost);
            dragState.ghost = ghost;
        }

        function handleDragMove(e) {
            if (!dragState.active || !dragState.ghost) return;

            const shapeData = SHAPE_LIBRARY[dragState.shapeId];
            const rotation = shapeData.rotations[dragState.rotationIndex];
            const bounds = getShapeBounds(rotation);
            const cellSize = dragState.gridCellSize;

            const ghostWidth = bounds.width * cellSize;
            const ghostHeight = bounds.height * cellSize;

            // Update ghost position
            dragState.ghost.style.left = (e.clientX - ghostWidth / 2) + 'px';
            dragState.ghost.style.top = (e.clientY - ghostHeight / 2) + 'px';

            // Check if over puzzle grid and highlight cells
            const puzzleGrid = document.getElementById('puzzleGrid');
            if (!puzzleGrid) return;

            const gridRect = puzzleGrid.getBoundingClientRect();
            const gridX = e.clientX - gridRect.left;
            const gridY = e.clientY - gridRect.top;

            // Clear previous highlights
            clearGridHighlights();

            // Check if cursor is within grid bounds
            if (gridX >= 0 && gridX < gridRect.width && gridY >= 0 && gridY < gridRect.height) {
                // Calculate grid cell under cursor
                const col = Math.floor(gridX / cellSize);
                const row = Math.floor(gridY / cellSize);

                // Adjust to place shape centered/offset from cursor
                const startRow = row - Math.floor(bounds.height / 2);
                const startCol = col - Math.floor(bounds.width / 2);

                dragState.lastGridCell = { row: startRow, col: startCol };

                // Check validity and highlight cells
                const validity = checkPlacementValidity(startRow, startCol, rotation);
                highlightPlacementCells(startRow, startCol, rotation, validity);
            } else {
                dragState.lastGridCell = null;
            }
        }

        function handleDragKeyDown(e) {
            if (!dragState.active) return;

            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();

                // Rotate to next rotation
                const shapeData = SHAPE_LIBRARY[dragState.shapeId];
                dragState.rotationIndex = (dragState.rotationIndex + 1) % shapeData.rotations.length;

                // Recreate ghost with new rotation
                const ghost = dragState.ghost;
                if (ghost) {
                    const rect = ghost.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    createDragGhost(centerX, centerY);
                }

                // Update grid highlights
                if (dragState.lastGridCell) {
                    clearGridHighlights();
                    const shapeData = SHAPE_LIBRARY[dragState.shapeId];
                    const rotation = shapeData.rotations[dragState.rotationIndex];
                    const validity = checkPlacementValidity(
                        dragState.lastGridCell.row,
                        dragState.lastGridCell.col,
                        rotation
                    );
                    highlightPlacementCells(
                        dragState.lastGridCell.row,
                        dragState.lastGridCell.col,
                        rotation,
                        validity
                    );
                }
            }
        }

        function handleDragEnd(e) {
            if (!dragState.active) return;

            // Remove listeners
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('keydown', handleDragKeyDown);

            // Try to place shape
            let placed = false;
            if (dragState.lastGridCell) {
                const shapeData = SHAPE_LIBRARY[dragState.shapeId];
                const rotation = shapeData.rotations[dragState.rotationIndex];
                const validity = checkPlacementValidity(
                    dragState.lastGridCell.row,
                    dragState.lastGridCell.col,
                    rotation
                );

                if (validity.valid) {
                    placeShapeOnGrid(
                        dragState.lastGridCell.row,
                        dragState.lastGridCell.col,
                        rotation,
                        dragState.color,
                        dragState.shapeId,
                        dragState.rotationIndex
                    );
                    placed = true;

                    // Remove shape from palette
                    if (dragState.sourceElement) {
                        dragState.sourceElement.remove();
                    }
                }
            }

            // Restore source element if not placed
            if (!placed && dragState.sourceElement) {
                dragState.sourceElement.style.opacity = '1';
            }

            // Clean up
            clearGridHighlights();
            if (dragState.ghost) {
                dragState.ghost.remove();
            }

            dragState = {
                active: false,
                shapeId: null,
                color: null,
                rotationIndex: 0,
                sourceElement: null,
                ghost: null,
                gridCellSize: 68,
                lastGridCell: null
            };
        }

        function checkPlacementValidity(startRow, startCol, rotation) {
            const result = { valid: true, cells: [] };

            for (const [dr, dc] of rotation) {
                const r = startRow + dr;
                const c = startCol + dc;

                const cellInfo = { row: r, col: c, valid: true };

                // Check bounds
                if (r < 0 || r >= currentPuzzle.grid.length ||
                    c < 0 || c >= currentPuzzle.grid[0].length) {
                    cellInfo.valid = false;
                    result.valid = false;
                } else {
                    // Check cell state
                    const gridCell = document.querySelector(
                        `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                    );
                    if (gridCell) {
                        const state = gridCell.dataset.currentState;
                        if (state !== 'empty') {
                            cellInfo.valid = false;
                            result.valid = false;
                        }
                    }
                }

                result.cells.push(cellInfo);
            }

            return result;
        }

        function highlightPlacementCells(startRow, startCol, rotation, validity) {
            for (const cellInfo of validity.cells) {
                if (cellInfo.row < 0 || cellInfo.row >= currentPuzzle.grid.length ||
                    cellInfo.col < 0 || cellInfo.col >= currentPuzzle.grid[0].length) {
                    continue;
                }

                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${cellInfo.row}"][data-col="${cellInfo.col}"]`
                );
                if (gridCell) {
                    if (validity.valid) {
                        gridCell.classList.add('placement-valid');
                    } else {
                        gridCell.classList.add('placement-invalid');
                    }
                }
            }
        }

        function clearGridHighlights() {
            document.querySelectorAll('#puzzleGrid .cell').forEach(cell => {
                cell.classList.remove('placement-valid', 'placement-invalid');
            });
        }

        function placeShapeOnGrid(startRow, startCol, rotation, color, shapeId, rotationIndex) {
            // Build a set of all cells in this shape for neighbor checking
            const cellSet = new Set(rotation.map(([dr, dc]) => `${startRow + dr},${startCol + dc}`));

            rotation.forEach(([dr, dc], cellIndex) => {
                const r = startRow + dr;
                const c = startCol + dc;

                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                );
                if (gridCell) {
                    gridCell.classList.add(color);
                    gridCell.classList.add('placed');
                    gridCell.dataset.currentState = color;
                    gridCell.dataset.placedShapeId = shapeId;
                    gridCell.dataset.placedRotation = rotationIndex;

                    // Alternating shade based on checkerboard pattern (row + col parity)
                    if ((r + c) % 2 === 1) {
                        gridCell.classList.add('shade-alt');
                    }

                    // Check neighbors for border edges
                    const topKey = `${r - 1},${c}`;
                    const rightKey = `${r},${c + 1}`;
                    const bottomKey = `${r + 1},${c}`;
                    const leftKey = `${r},${c - 1}`;

                    // Check diagonals for Inner Corners
                    const tlKey = `${r - 1},${c - 1}`;
                    const trKey = `${r - 1},${c + 1}`;
                    const brKey = `${r + 1},${c + 1}`;
                    const blKey = `${r + 1},${c - 1}`;

                    const hasTop = !cellSet.has(topKey);
                    const hasRight = !cellSet.has(rightKey);
                    const hasBottom = !cellSet.has(bottomKey);
                    const hasLeft = !cellSet.has(leftKey);

                    // Apply Borders
                    if (hasTop) gridCell.classList.add('border-top');
                    if (hasRight) gridCell.classList.add('border-right');
                    if (hasBottom) gridCell.classList.add('border-bottom');
                    if (hasLeft) gridCell.classList.add('border-left');

                    // Apply Inner Corners
                    if (!hasTop && !hasLeft && !cellSet.has(tlKey)) gridCell.classList.add('corner-tl');
                    if (!hasTop && !hasRight && !cellSet.has(trKey)) gridCell.classList.add('corner-tr');
                    if (!hasBottom && !hasRight && !cellSet.has(brKey)) gridCell.classList.add('corner-br');
                    if (!hasBottom && !hasLeft && !cellSet.has(blKey)) gridCell.classList.add('corner-bl');
                }
            });

            // Update requirements bars
            updatePuzzleBars();

            // Check win condition
            checkWinCondition();
        }

        function updatePuzzleBars() {
            if (!currentPuzzle) return;

            const colors = puzzleConfig.colors;
            const grid = currentPuzzle.grid;
            const rows = grid.length;
            const cols = grid[0].length;

            // Count current fills per row/col/color
            for (let r = 0; r < rows; r++) {
                for (const color of colors) {
                    let count = 0;
                    for (let c = 0; c < cols; c++) {
                        const cell = document.querySelector(
                            `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                        );
                        if (cell && (cell.dataset.currentState === color ||
                            cell.dataset.currentState === `locked-${color}`)) {
                            count++;
                        }
                    }

                    // Update row bar
                    const bar = document.querySelector(
                        `.prescriptive-bar[data-type="row"][data-index="${r}"][data-color="${color}"]`
                    );
                    if (bar) {
                        const required = parseInt(bar.dataset.required);
                        const segments = bar.querySelectorAll('.prescriptive-segment');
                        const colorMap = {
                            green: '#39ff14',
                            blue: '#00bfff',
                            red: '#ff3939',
                            purple: '#bf39ff'
                        };

                        segments.forEach((seg, i) => {
                            if (i < count) {
                                seg.classList.add('filled');
                                seg.style.background = colorMap[color];
                            } else {
                                seg.classList.remove('filled');
                                seg.style.background = 'transparent';
                            }
                        });

                        // Error state if exceeded
                        if (count > required) {
                            bar.classList.add('error');
                        } else {
                            bar.classList.remove('error');
                        }
                    }
                }
            }

            for (let c = 0; c < cols; c++) {
                for (const color of colors) {
                    let count = 0;
                    for (let r = 0; r < rows; r++) {
                        const cell = document.querySelector(
                            `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                        );
                        if (cell && (cell.dataset.currentState === color ||
                            cell.dataset.currentState === `locked-${color}`)) {
                            count++;
                        }
                    }

                    // Update col bar
                    const bar = document.querySelector(
                        `.prescriptive-bar[data-type="col"][data-index="${c}"][data-color="${color}"]`
                    );
                    if (bar) {
                        const required = parseInt(bar.dataset.required);
                        const segments = bar.querySelectorAll('.prescriptive-segment');
                        const colorMap = {
                            green: '#39ff14',
                            blue: '#00bfff',
                            red: '#ff3939',
                            purple: '#bf39ff'
                        };

                        segments.forEach((seg, i) => {
                            if (i < count) {
                                seg.classList.add('filled');
                                seg.style.background = colorMap[color];
                            } else {
                                seg.classList.remove('filled');
                                seg.style.background = 'transparent';
                            }
                        });

                        // Error state if exceeded
                        if (count > required) {
                            bar.classList.add('error');
                        } else {
                            bar.classList.remove('error');
                        }
                    }
                }
            }
        }

        function handleCellRightClick(e) {
            e.preventDefault();
            const cell = e.target.closest('.cell');
            if (!cell || !cell.classList.contains('placed')) return;

            const shapeId = cell.dataset.placedShapeId;
            const rotationIndex = parseInt(cell.dataset.placedRotation);

            // Find color from cell class
            let color = null;
            for (const c of puzzleConfig.colors) {
                if (cell.classList.contains(c)) {
                    color = c;
                    break;
                }
            }
            if (!color) return;

            // Find all cells of this placed shape
            const allPlacedCells = document.querySelectorAll(
                `#puzzleGrid .cell.placed[data-placed-shape-id="${shapeId}"]`
            );

            // Remove all cells of this shape instance directly
            // This avoids issues where calculating origin/rotation might miss cells
            allPlacedCells.forEach(gridCell => {
                gridCell.classList.remove(color, 'placed', 'shade-alt',
                    'border-top', 'border-right', 'border-bottom', 'border-left',
                    'corner-tl', 'corner-tr', 'corner-br', 'corner-bl');
                gridCell.dataset.currentState = 'empty';
                delete gridCell.dataset.placedShapeId;
                delete gridCell.dataset.placedRotation;
            });

            // Add shape back to palette
            addShapeToPalette(shapeId, color, rotationIndex);

            // Update bars
            updatePuzzleBars();
        }

        function addShapeToPalette(shapeId, color, placedRotationIndex) {
            const palette = document.getElementById('paletteShapes');

            // Look up the solution data from the current puzzle
            const solutionShapes = currentPuzzle.shapes[color] || [];
            const solutionShape = solutionShapes.find(s => s.shapeId === shapeId);

            const shapeEl = document.createElement('div');
            shapeEl.className = `palette-shape ${color}`;
            shapeEl.dataset.shapeId = shapeId;
            shapeEl.dataset.color = color;

            // Randomize display rotation (not the solution rotation)
            const shapeData = SHAPE_LIBRARY[shapeId];
            const randomDisplayRotation = Math.floor(Math.random() * shapeData.rotations.length);
            shapeEl.dataset.rotationIndex = randomDisplayRotation;

            // Store solution data if available (for hints to work)
            if (solutionShape) {
                shapeEl.dataset.solutionRotationIndex = solutionShape.rotationIndex;
                shapeEl.dataset.solutionRow = solutionShape.position[0];
                shapeEl.dataset.solutionCol = solutionShape.position[1];
            }

            shapeEl.style.cursor = 'grab';

            const rotation = shapeData.rotations[randomDisplayRotation];
            const bounds = getShapeBounds(rotation);

            const preview = document.createElement('div');
            preview.className = 'shape-preview-grid';
            preview.style.display = 'grid';
            preview.style.gridTemplateColumns = `repeat(${bounds.width}, 12px)`;
            preview.style.gridTemplateRows = `repeat(${bounds.height}, 12px)`;
            preview.style.gap = '1px';

            for (let r = 0; r < bounds.height; r++) {
                for (let c = 0; c < bounds.width; c++) {
                    const cell = document.createElement('div');
                    cell.style.width = '12px';
                    cell.style.height = '12px';

                    const isShapeCell = rotation.some(([sr, sc]) => sr === r && sc === c);
                    if (isShapeCell) {
                        cell.className = `shape-preview-cell ${color}`;
                    } else {
                        cell.style.background = 'transparent';
                    }

                    preview.appendChild(cell);
                }
            }

            shapeEl.appendChild(preview);
            shapeEl.addEventListener('mousedown', handleShapeMouseDown);
            palette.appendChild(shapeEl);
        }

        function checkWinCondition() {
            if (!currentPuzzle) return;

            // Check if palette is empty
            const remainingShapes = document.querySelectorAll('#paletteShapes .palette-shape');
            if (remainingShapes.length > 0) return;

            // Check all requirements are met exactly
            const bars = document.querySelectorAll('.prescriptive-bar');
            for (const bar of bars) {
                if (bar.classList.contains('error')) return;

                const required = parseInt(bar.dataset.required);
                const filled = bar.querySelectorAll('.prescriptive-segment.filled').length;
                if (filled !== required) return;
            }

            // Win!
            showToast('ðŸŽ‰ Puzzle Complete! Congratulations!', 'success', 5000);
        }

        function clearCellsForPlacement(startRow, startCol, rotation) {
            // Clear any placed shapes from cells needed for this placement
            // Returns array of shapes that were removed (to add back to palette)
            const removedShapes = [];
            const cellsToProcess = new Set();

            // Collect all cells that need to be cleared
            for (const [dr, dc] of rotation) {
                const r = startRow + dr;
                const c = startCol + dc;
                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                );
                if (gridCell && gridCell.classList.contains('placed')) {
                    cellsToProcess.add(`${r},${c}`);
                }
            }

            // For each cell with a placed shape, find and remove the entire shape
            const processedShapes = new Set();
            cellsToProcess.forEach(cellKey => {
                const [r, c] = cellKey.split(',').map(Number);
                const gridCell = document.querySelector(
                    `#puzzleGrid .cell[data-row="${r}"][data-col="${c}"]`
                );
                if (!gridCell || !gridCell.classList.contains('placed')) return;

                const placedShapeId = gridCell.dataset.placedShapeId;
                const placedRotation = parseInt(gridCell.dataset.placedRotation);

                // Find the color
                let placedColor = null;
                for (const col of puzzleConfig.colors) {
                    if (gridCell.classList.contains(col)) {
                        placedColor = col;
                        break;
                    }
                }
                if (!placedColor) return;

                // Create unique key for this shape instance
                const shapeKey = `${placedShapeId}-${placedColor}-${r}-${c}`;
                if (processedShapes.has(shapeKey)) return;

                // Find all cells of this shape and get its origin
                const shapeData = SHAPE_LIBRARY[placedShapeId];
                const shapeRotation = shapeData.rotations[placedRotation];

                // Find origin by checking which offset makes this cell match
                let originRow = null, originCol = null;
                for (const [dr, dc] of shapeRotation) {
                    const testOriginR = r - dr;
                    const testOriginC = c - dc;
                    // Verify this origin works for all cells
                    let valid = true;
                    for (const [dr2, dc2] of shapeRotation) {
                        const checkCell = document.querySelector(
                            `#puzzleGrid .cell[data-row="${testOriginR + dr2}"][data-col="${testOriginC + dc2}"]`
                        );
                        if (!checkCell || !checkCell.classList.contains('placed') ||
                            checkCell.dataset.placedShapeId !== placedShapeId) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) {
                        originRow = testOriginR;
                        originCol = testOriginC;
                        break;
                    }
                }

                if (originRow === null) return;

                // Mark this shape as processed
                processedShapes.add(`${placedShapeId}-${placedColor}-${originRow}-${originCol}`);

                // Remove all cells of this shape
                for (const [dr, dc] of shapeRotation) {
                    const cellR = originRow + dr;
                    const cellC = originCol + dc;
                    const cell = document.querySelector(
                        `#puzzleGrid .cell[data-row="${cellR}"][data-col="${cellC}"]`
                    );
                    if (cell) {
                        cell.classList.remove(placedColor, 'placed', 'shade-alt',
                            'border-top', 'border-right', 'border-bottom', 'border-left',
                            'corner-tl', 'corner-tr', 'corner-br', 'corner-bl');
                                cell.dataset.currentState = 'empty';
                        delete cell.dataset.placedShapeId;
                        delete cell.dataset.placedRotation;
                    }
                }

                // Track removed shape to add back to palette
                removedShapes.push({
                    shapeId: placedShapeId,
                    color: placedColor,
                    rotationIndex: placedRotation
                });
            });

            return removedShapes;
        }

        function showOneHint() {
            if (!currentPuzzle) return;

            // Get remaining shapes from palette
            const remainingShapes = document.querySelectorAll('#paletteShapes .palette-shape');
            if (remainingShapes.length === 0) {
                showToast('No shapes left to hint!', 'info', 2000);
                return;
            }

            // Pick a random shape
            const randomIndex = Math.floor(Math.random() * remainingShapes.length);
            const shapeEl = remainingShapes[randomIndex];

            // Get solution position from data attributes
            const shapeId = shapeEl.dataset.shapeId;
            const color = shapeEl.dataset.color;
            // Use the SOLUTION rotation index, not the current display rotation
            const solutionRotationIndex = parseInt(shapeEl.dataset.solutionRotationIndex);
            const solutionRow = parseInt(shapeEl.dataset.solutionRow);
            const solutionCol = parseInt(shapeEl.dataset.solutionCol);

            // Get the rotation cells using the solution rotation
            const shapeData = SHAPE_LIBRARY[shapeId];
            const rotation = shapeData.rotations[solutionRotationIndex];

            // Clear any incorrectly placed shapes from the solution cells
            const removedShapes = clearCellsForPlacement(solutionRow, solutionCol, rotation);

            // Add removed shapes back to palette (with randomized display rotation)
            for (const shape of removedShapes) {
                addShapeToPalette(shape.shapeId, shape.color, shape.rotationIndex);
            }

            // Place the shape at its solution position with the solution rotation
            placeShapeOnGrid(solutionRow, solutionCol, rotation, color, shapeId, solutionRotationIndex);

            // Remove from palette
            shapeEl.remove();

            // Update bars after all changes
            updatePuzzleBars();

            showToast('Hint: placed one shape', 'info', 2000);

            // Check win condition
            checkWinCondition();
        }

        function showSolution() {
            if (!currentPuzzle) return;

            // First, clear ALL placed shapes from the grid
            const allPlacedCells = document.querySelectorAll('#puzzleGrid .cell.placed');
            allPlacedCells.forEach(cell => {
                for (const color of puzzleConfig.colors) {
                    cell.classList.remove(color);
                }
                cell.classList.remove('placed', 'shade-alt',
                    'border-top', 'border-right', 'border-bottom', 'border-left');
                cell.dataset.currentState = 'empty';
                delete cell.dataset.placedShapeId;
                delete cell.dataset.placedRotation;
            });

            // Clear the palette
            const palette = document.getElementById('paletteShapes');
            palette.innerHTML = '';

            // Place ALL shapes from the original puzzle at their solution positions
            for (const color of puzzleConfig.colors) {
                const shapes = currentPuzzle.shapes[color] || [];
                for (const shape of shapes) {
                    const shapeData = SHAPE_LIBRARY[shape.shapeId];
                    const rotation = shapeData.rotations[shape.rotationIndex];
                    placeShapeOnGrid(
                        shape.position[0],
                        shape.position[1],
                        rotation,
                        color,
                        shape.shapeId,
                        shape.rotationIndex
                    );
                }
            }

            // Update bars
            updatePuzzleBars();

            showToast('Solution revealed!', 'info', 3000);

            // Check win
            checkWinCondition();
        }

        function resetPuzzle() {
            if (currentPuzzle) {
                renderPuzzlePlayArea(currentPuzzle);
            }
        }

        window.onload = function() {
            generateGrid();
            renderShapeSelector();
            setTimeout(updateSliderToggle, 0);
        };
    </script>
</body>
</html>
